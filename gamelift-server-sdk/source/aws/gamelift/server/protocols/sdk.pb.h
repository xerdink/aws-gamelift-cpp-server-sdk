// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sdk.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_sdk_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_sdk_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_sdk_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_sdk_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[27]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_sdk_2eproto;
namespace com {
namespace amazon {
namespace whitewater {
namespace auxproxy {
namespace pbuffer {
class AcceptPlayerSession;
class AcceptPlayerSessionDefaultTypeInternal;
extern AcceptPlayerSessionDefaultTypeInternal _AcceptPlayerSession_default_instance_;
class ActivateGameSession;
class ActivateGameSessionDefaultTypeInternal;
extern ActivateGameSessionDefaultTypeInternal _ActivateGameSession_default_instance_;
class AttributeValue;
class AttributeValueDefaultTypeInternal;
extern AttributeValueDefaultTypeInternal _AttributeValue_default_instance_;
class AttributeValue_SDMEntry_DoNotUse;
class AttributeValue_SDMEntry_DoNotUseDefaultTypeInternal;
extern AttributeValue_SDMEntry_DoNotUseDefaultTypeInternal _AttributeValue_SDMEntry_DoNotUse_default_instance_;
class BackfillMatchmakingRequest;
class BackfillMatchmakingRequestDefaultTypeInternal;
extern BackfillMatchmakingRequestDefaultTypeInternal _BackfillMatchmakingRequest_default_instance_;
class BackfillMatchmakingResponse;
class BackfillMatchmakingResponseDefaultTypeInternal;
extern BackfillMatchmakingResponseDefaultTypeInternal _BackfillMatchmakingResponse_default_instance_;
class DescribePlayerSessionsRequest;
class DescribePlayerSessionsRequestDefaultTypeInternal;
extern DescribePlayerSessionsRequestDefaultTypeInternal _DescribePlayerSessionsRequest_default_instance_;
class DescribePlayerSessionsResponse;
class DescribePlayerSessionsResponseDefaultTypeInternal;
extern DescribePlayerSessionsResponseDefaultTypeInternal _DescribePlayerSessionsResponse_default_instance_;
class GameLiftResponse;
class GameLiftResponseDefaultTypeInternal;
extern GameLiftResponseDefaultTypeInternal _GameLiftResponse_default_instance_;
class GameProperty;
class GamePropertyDefaultTypeInternal;
extern GamePropertyDefaultTypeInternal _GameProperty_default_instance_;
class GameSession;
class GameSessionDefaultTypeInternal;
extern GameSessionDefaultTypeInternal _GameSession_default_instance_;
class GameSessionActivate;
class GameSessionActivateDefaultTypeInternal;
extern GameSessionActivateDefaultTypeInternal _GameSessionActivate_default_instance_;
class GameSessionTerminate;
class GameSessionTerminateDefaultTypeInternal;
extern GameSessionTerminateDefaultTypeInternal _GameSessionTerminate_default_instance_;
class GetInstanceCertificate;
class GetInstanceCertificateDefaultTypeInternal;
extern GetInstanceCertificateDefaultTypeInternal _GetInstanceCertificate_default_instance_;
class GetInstanceCertificateResponse;
class GetInstanceCertificateResponseDefaultTypeInternal;
extern GetInstanceCertificateResponseDefaultTypeInternal _GetInstanceCertificateResponse_default_instance_;
class Player;
class PlayerDefaultTypeInternal;
extern PlayerDefaultTypeInternal _Player_default_instance_;
class PlayerSession;
class PlayerSessionDefaultTypeInternal;
extern PlayerSessionDefaultTypeInternal _PlayerSession_default_instance_;
class Player_LatencyInMsEntry_DoNotUse;
class Player_LatencyInMsEntry_DoNotUseDefaultTypeInternal;
extern Player_LatencyInMsEntry_DoNotUseDefaultTypeInternal _Player_LatencyInMsEntry_DoNotUse_default_instance_;
class Player_PlayerAttributesEntry_DoNotUse;
class Player_PlayerAttributesEntry_DoNotUseDefaultTypeInternal;
extern Player_PlayerAttributesEntry_DoNotUseDefaultTypeInternal _Player_PlayerAttributesEntry_DoNotUse_default_instance_;
class ProcessEnding;
class ProcessEndingDefaultTypeInternal;
extern ProcessEndingDefaultTypeInternal _ProcessEnding_default_instance_;
class ProcessReady;
class ProcessReadyDefaultTypeInternal;
extern ProcessReadyDefaultTypeInternal _ProcessReady_default_instance_;
class RemovePlayerSession;
class RemovePlayerSessionDefaultTypeInternal;
extern RemovePlayerSessionDefaultTypeInternal _RemovePlayerSession_default_instance_;
class ReportHealth;
class ReportHealthDefaultTypeInternal;
extern ReportHealthDefaultTypeInternal _ReportHealth_default_instance_;
class StopMatchmakingRequest;
class StopMatchmakingRequestDefaultTypeInternal;
extern StopMatchmakingRequestDefaultTypeInternal _StopMatchmakingRequest_default_instance_;
class TerminateProcess;
class TerminateProcessDefaultTypeInternal;
extern TerminateProcessDefaultTypeInternal _TerminateProcess_default_instance_;
class UpdateGameSession;
class UpdateGameSessionDefaultTypeInternal;
extern UpdateGameSessionDefaultTypeInternal _UpdateGameSession_default_instance_;
class UpdatePlayerSessionCreationPolicy;
class UpdatePlayerSessionCreationPolicyDefaultTypeInternal;
extern UpdatePlayerSessionCreationPolicyDefaultTypeInternal _UpdatePlayerSessionCreationPolicy_default_instance_;
}  // namespace pbuffer
}  // namespace auxproxy
}  // namespace whitewater
}  // namespace amazon
}  // namespace com
PROTOBUF_NAMESPACE_OPEN
template<> ::com::amazon::whitewater::auxproxy::pbuffer::AcceptPlayerSession* Arena::CreateMaybeMessage<::com::amazon::whitewater::auxproxy::pbuffer::AcceptPlayerSession>(Arena*);
template<> ::com::amazon::whitewater::auxproxy::pbuffer::ActivateGameSession* Arena::CreateMaybeMessage<::com::amazon::whitewater::auxproxy::pbuffer::ActivateGameSession>(Arena*);
template<> ::com::amazon::whitewater::auxproxy::pbuffer::AttributeValue* Arena::CreateMaybeMessage<::com::amazon::whitewater::auxproxy::pbuffer::AttributeValue>(Arena*);
template<> ::com::amazon::whitewater::auxproxy::pbuffer::AttributeValue_SDMEntry_DoNotUse* Arena::CreateMaybeMessage<::com::amazon::whitewater::auxproxy::pbuffer::AttributeValue_SDMEntry_DoNotUse>(Arena*);
template<> ::com::amazon::whitewater::auxproxy::pbuffer::BackfillMatchmakingRequest* Arena::CreateMaybeMessage<::com::amazon::whitewater::auxproxy::pbuffer::BackfillMatchmakingRequest>(Arena*);
template<> ::com::amazon::whitewater::auxproxy::pbuffer::BackfillMatchmakingResponse* Arena::CreateMaybeMessage<::com::amazon::whitewater::auxproxy::pbuffer::BackfillMatchmakingResponse>(Arena*);
template<> ::com::amazon::whitewater::auxproxy::pbuffer::DescribePlayerSessionsRequest* Arena::CreateMaybeMessage<::com::amazon::whitewater::auxproxy::pbuffer::DescribePlayerSessionsRequest>(Arena*);
template<> ::com::amazon::whitewater::auxproxy::pbuffer::DescribePlayerSessionsResponse* Arena::CreateMaybeMessage<::com::amazon::whitewater::auxproxy::pbuffer::DescribePlayerSessionsResponse>(Arena*);
template<> ::com::amazon::whitewater::auxproxy::pbuffer::GameLiftResponse* Arena::CreateMaybeMessage<::com::amazon::whitewater::auxproxy::pbuffer::GameLiftResponse>(Arena*);
template<> ::com::amazon::whitewater::auxproxy::pbuffer::GameProperty* Arena::CreateMaybeMessage<::com::amazon::whitewater::auxproxy::pbuffer::GameProperty>(Arena*);
template<> ::com::amazon::whitewater::auxproxy::pbuffer::GameSession* Arena::CreateMaybeMessage<::com::amazon::whitewater::auxproxy::pbuffer::GameSession>(Arena*);
template<> ::com::amazon::whitewater::auxproxy::pbuffer::GameSessionActivate* Arena::CreateMaybeMessage<::com::amazon::whitewater::auxproxy::pbuffer::GameSessionActivate>(Arena*);
template<> ::com::amazon::whitewater::auxproxy::pbuffer::GameSessionTerminate* Arena::CreateMaybeMessage<::com::amazon::whitewater::auxproxy::pbuffer::GameSessionTerminate>(Arena*);
template<> ::com::amazon::whitewater::auxproxy::pbuffer::GetInstanceCertificate* Arena::CreateMaybeMessage<::com::amazon::whitewater::auxproxy::pbuffer::GetInstanceCertificate>(Arena*);
template<> ::com::amazon::whitewater::auxproxy::pbuffer::GetInstanceCertificateResponse* Arena::CreateMaybeMessage<::com::amazon::whitewater::auxproxy::pbuffer::GetInstanceCertificateResponse>(Arena*);
template<> ::com::amazon::whitewater::auxproxy::pbuffer::Player* Arena::CreateMaybeMessage<::com::amazon::whitewater::auxproxy::pbuffer::Player>(Arena*);
template<> ::com::amazon::whitewater::auxproxy::pbuffer::PlayerSession* Arena::CreateMaybeMessage<::com::amazon::whitewater::auxproxy::pbuffer::PlayerSession>(Arena*);
template<> ::com::amazon::whitewater::auxproxy::pbuffer::Player_LatencyInMsEntry_DoNotUse* Arena::CreateMaybeMessage<::com::amazon::whitewater::auxproxy::pbuffer::Player_LatencyInMsEntry_DoNotUse>(Arena*);
template<> ::com::amazon::whitewater::auxproxy::pbuffer::Player_PlayerAttributesEntry_DoNotUse* Arena::CreateMaybeMessage<::com::amazon::whitewater::auxproxy::pbuffer::Player_PlayerAttributesEntry_DoNotUse>(Arena*);
template<> ::com::amazon::whitewater::auxproxy::pbuffer::ProcessEnding* Arena::CreateMaybeMessage<::com::amazon::whitewater::auxproxy::pbuffer::ProcessEnding>(Arena*);
template<> ::com::amazon::whitewater::auxproxy::pbuffer::ProcessReady* Arena::CreateMaybeMessage<::com::amazon::whitewater::auxproxy::pbuffer::ProcessReady>(Arena*);
template<> ::com::amazon::whitewater::auxproxy::pbuffer::RemovePlayerSession* Arena::CreateMaybeMessage<::com::amazon::whitewater::auxproxy::pbuffer::RemovePlayerSession>(Arena*);
template<> ::com::amazon::whitewater::auxproxy::pbuffer::ReportHealth* Arena::CreateMaybeMessage<::com::amazon::whitewater::auxproxy::pbuffer::ReportHealth>(Arena*);
template<> ::com::amazon::whitewater::auxproxy::pbuffer::StopMatchmakingRequest* Arena::CreateMaybeMessage<::com::amazon::whitewater::auxproxy::pbuffer::StopMatchmakingRequest>(Arena*);
template<> ::com::amazon::whitewater::auxproxy::pbuffer::TerminateProcess* Arena::CreateMaybeMessage<::com::amazon::whitewater::auxproxy::pbuffer::TerminateProcess>(Arena*);
template<> ::com::amazon::whitewater::auxproxy::pbuffer::UpdateGameSession* Arena::CreateMaybeMessage<::com::amazon::whitewater::auxproxy::pbuffer::UpdateGameSession>(Arena*);
template<> ::com::amazon::whitewater::auxproxy::pbuffer::UpdatePlayerSessionCreationPolicy* Arena::CreateMaybeMessage<::com::amazon::whitewater::auxproxy::pbuffer::UpdatePlayerSessionCreationPolicy>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace com {
namespace amazon {
namespace whitewater {
namespace auxproxy {
namespace pbuffer {

enum GameLiftResponseStatus : int {
  OK = 0,
  ERROR_400 = 1,
  ERROR_500 = 2,
  UNRECOGNIZED = -1
};
bool GameLiftResponseStatus_IsValid(int value);
constexpr GameLiftResponseStatus GameLiftResponseStatus_MIN = UNRECOGNIZED;
constexpr GameLiftResponseStatus GameLiftResponseStatus_MAX = ERROR_500;
constexpr int GameLiftResponseStatus_ARRAYSIZE = GameLiftResponseStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GameLiftResponseStatus_descriptor();
template<typename T>
inline const std::string& GameLiftResponseStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GameLiftResponseStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GameLiftResponseStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GameLiftResponseStatus_descriptor(), enum_t_value);
}
inline bool GameLiftResponseStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GameLiftResponseStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GameLiftResponseStatus>(
    GameLiftResponseStatus_descriptor(), name, value);
}
// ===================================================================

class GameLiftResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.amazon.whitewater.auxproxy.pbuffer.GameLiftResponse) */ {
 public:
  inline GameLiftResponse() : GameLiftResponse(nullptr) {}
  virtual ~GameLiftResponse();

  GameLiftResponse(const GameLiftResponse& from);
  GameLiftResponse(GameLiftResponse&& from) noexcept
    : GameLiftResponse() {
    *this = ::std::move(from);
  }

  inline GameLiftResponse& operator=(const GameLiftResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameLiftResponse& operator=(GameLiftResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameLiftResponse& default_instance();

  static inline const GameLiftResponse* internal_default_instance() {
    return reinterpret_cast<const GameLiftResponse*>(
               &_GameLiftResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GameLiftResponse& a, GameLiftResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GameLiftResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameLiftResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameLiftResponse* New() const final {
    return CreateMaybeMessage<GameLiftResponse>(nullptr);
  }

  GameLiftResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameLiftResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameLiftResponse& from);
  void MergeFrom(const GameLiftResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameLiftResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.amazon.whitewater.auxproxy.pbuffer.GameLiftResponse";
  }
  protected:
  explicit GameLiftResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sdk_2eproto);
    return ::descriptor_table_sdk_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseDataFieldNumber = 2,
    kErrorMessageFieldNumber = 3,
    kStatusFieldNumber = 1,
  };
  // optional string responseData = 2;
  bool has_responsedata() const;
  private:
  bool _internal_has_responsedata() const;
  public:
  void clear_responsedata();
  const std::string& responsedata() const;
  void set_responsedata(const std::string& value);
  void set_responsedata(std::string&& value);
  void set_responsedata(const char* value);
  void set_responsedata(const char* value, size_t size);
  std::string* mutable_responsedata();
  std::string* release_responsedata();
  void set_allocated_responsedata(std::string* responsedata);
  private:
  const std::string& _internal_responsedata() const;
  void _internal_set_responsedata(const std::string& value);
  std::string* _internal_mutable_responsedata();
  public:

  // optional string errorMessage = 3;
  bool has_errormessage() const;
  private:
  bool _internal_has_errormessage() const;
  public:
  void clear_errormessage();
  const std::string& errormessage() const;
  void set_errormessage(const std::string& value);
  void set_errormessage(std::string&& value);
  void set_errormessage(const char* value);
  void set_errormessage(const char* value, size_t size);
  std::string* mutable_errormessage();
  std::string* release_errormessage();
  void set_allocated_errormessage(std::string* errormessage);
  private:
  const std::string& _internal_errormessage() const;
  void _internal_set_errormessage(const std::string& value);
  std::string* _internal_mutable_errormessage();
  public:

  // optional .com.amazon.whitewater.auxproxy.pbuffer.GameLiftResponseStatus status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::com::amazon::whitewater::auxproxy::pbuffer::GameLiftResponseStatus status() const;
  void set_status(::com::amazon::whitewater::auxproxy::pbuffer::GameLiftResponseStatus value);
  private:
  ::com::amazon::whitewater::auxproxy::pbuffer::GameLiftResponseStatus _internal_status() const;
  void _internal_set_status(::com::amazon::whitewater::auxproxy::pbuffer::GameLiftResponseStatus value);
  public:

  // @@protoc_insertion_point(class_scope:com.amazon.whitewater.auxproxy.pbuffer.GameLiftResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr responsedata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errormessage_;
  int status_;
  friend struct ::TableStruct_sdk_2eproto;
};
// -------------------------------------------------------------------

class GameProperty PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.amazon.whitewater.auxproxy.pbuffer.GameProperty) */ {
 public:
  inline GameProperty() : GameProperty(nullptr) {}
  virtual ~GameProperty();

  GameProperty(const GameProperty& from);
  GameProperty(GameProperty&& from) noexcept
    : GameProperty() {
    *this = ::std::move(from);
  }

  inline GameProperty& operator=(const GameProperty& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameProperty& operator=(GameProperty&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameProperty& default_instance();

  static inline const GameProperty* internal_default_instance() {
    return reinterpret_cast<const GameProperty*>(
               &_GameProperty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GameProperty& a, GameProperty& b) {
    a.Swap(&b);
  }
  inline void Swap(GameProperty* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameProperty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameProperty* New() const final {
    return CreateMaybeMessage<GameProperty>(nullptr);
  }

  GameProperty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameProperty>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameProperty& from);
  void MergeFrom(const GameProperty& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameProperty* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.amazon.whitewater.auxproxy.pbuffer.GameProperty";
  }
  protected:
  explicit GameProperty(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sdk_2eproto);
    return ::descriptor_table_sdk_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // optional string key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // optional string value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:com.amazon.whitewater.auxproxy.pbuffer.GameProperty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  friend struct ::TableStruct_sdk_2eproto;
};
// -------------------------------------------------------------------

class GameSession PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.amazon.whitewater.auxproxy.pbuffer.GameSession) */ {
 public:
  inline GameSession() : GameSession(nullptr) {}
  virtual ~GameSession();

  GameSession(const GameSession& from);
  GameSession(GameSession&& from) noexcept
    : GameSession() {
    *this = ::std::move(from);
  }

  inline GameSession& operator=(const GameSession& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameSession& operator=(GameSession&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameSession& default_instance();

  static inline const GameSession* internal_default_instance() {
    return reinterpret_cast<const GameSession*>(
               &_GameSession_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GameSession& a, GameSession& b) {
    a.Swap(&b);
  }
  inline void Swap(GameSession* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameSession* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameSession* New() const final {
    return CreateMaybeMessage<GameSession>(nullptr);
  }

  GameSession* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameSession>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameSession& from);
  void MergeFrom(const GameSession& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameSession* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.amazon.whitewater.auxproxy.pbuffer.GameSession";
  }
  protected:
  explicit GameSession(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sdk_2eproto);
    return ::descriptor_table_sdk_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGamePropertiesFieldNumber = 6,
    kGameSessionIdFieldNumber = 1,
    kFleetIdFieldNumber = 2,
    kNameFieldNumber = 3,
    kIpAddressFieldNumber = 8,
    kGameSessionDataFieldNumber = 9,
    kMatchmakerDataFieldNumber = 10,
    kDnsNameFieldNumber = 11,
    kMaxPlayersFieldNumber = 4,
    kJoinableFieldNumber = 5,
    kPortFieldNumber = 7,
  };
  // repeated .com.amazon.whitewater.auxproxy.pbuffer.GameProperty gameProperties = 6;
  int gameproperties_size() const;
  private:
  int _internal_gameproperties_size() const;
  public:
  void clear_gameproperties();
  ::com::amazon::whitewater::auxproxy::pbuffer::GameProperty* mutable_gameproperties(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::amazon::whitewater::auxproxy::pbuffer::GameProperty >*
      mutable_gameproperties();
  private:
  const ::com::amazon::whitewater::auxproxy::pbuffer::GameProperty& _internal_gameproperties(int index) const;
  ::com::amazon::whitewater::auxproxy::pbuffer::GameProperty* _internal_add_gameproperties();
  public:
  const ::com::amazon::whitewater::auxproxy::pbuffer::GameProperty& gameproperties(int index) const;
  ::com::amazon::whitewater::auxproxy::pbuffer::GameProperty* add_gameproperties();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::amazon::whitewater::auxproxy::pbuffer::GameProperty >&
      gameproperties() const;

  // optional string gameSessionId = 1;
  bool has_gamesessionid() const;
  private:
  bool _internal_has_gamesessionid() const;
  public:
  void clear_gamesessionid();
  const std::string& gamesessionid() const;
  void set_gamesessionid(const std::string& value);
  void set_gamesessionid(std::string&& value);
  void set_gamesessionid(const char* value);
  void set_gamesessionid(const char* value, size_t size);
  std::string* mutable_gamesessionid();
  std::string* release_gamesessionid();
  void set_allocated_gamesessionid(std::string* gamesessionid);
  private:
  const std::string& _internal_gamesessionid() const;
  void _internal_set_gamesessionid(const std::string& value);
  std::string* _internal_mutable_gamesessionid();
  public:

  // optional string fleetId = 2;
  bool has_fleetid() const;
  private:
  bool _internal_has_fleetid() const;
  public:
  void clear_fleetid();
  const std::string& fleetid() const;
  void set_fleetid(const std::string& value);
  void set_fleetid(std::string&& value);
  void set_fleetid(const char* value);
  void set_fleetid(const char* value, size_t size);
  std::string* mutable_fleetid();
  std::string* release_fleetid();
  void set_allocated_fleetid(std::string* fleetid);
  private:
  const std::string& _internal_fleetid() const;
  void _internal_set_fleetid(const std::string& value);
  std::string* _internal_mutable_fleetid();
  public:

  // optional string name = 3;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string ipAddress = 8;
  bool has_ipaddress() const;
  private:
  bool _internal_has_ipaddress() const;
  public:
  void clear_ipaddress();
  const std::string& ipaddress() const;
  void set_ipaddress(const std::string& value);
  void set_ipaddress(std::string&& value);
  void set_ipaddress(const char* value);
  void set_ipaddress(const char* value, size_t size);
  std::string* mutable_ipaddress();
  std::string* release_ipaddress();
  void set_allocated_ipaddress(std::string* ipaddress);
  private:
  const std::string& _internal_ipaddress() const;
  void _internal_set_ipaddress(const std::string& value);
  std::string* _internal_mutable_ipaddress();
  public:

  // optional string gameSessionData = 9;
  bool has_gamesessiondata() const;
  private:
  bool _internal_has_gamesessiondata() const;
  public:
  void clear_gamesessiondata();
  const std::string& gamesessiondata() const;
  void set_gamesessiondata(const std::string& value);
  void set_gamesessiondata(std::string&& value);
  void set_gamesessiondata(const char* value);
  void set_gamesessiondata(const char* value, size_t size);
  std::string* mutable_gamesessiondata();
  std::string* release_gamesessiondata();
  void set_allocated_gamesessiondata(std::string* gamesessiondata);
  private:
  const std::string& _internal_gamesessiondata() const;
  void _internal_set_gamesessiondata(const std::string& value);
  std::string* _internal_mutable_gamesessiondata();
  public:

  // optional string matchmakerData = 10;
  bool has_matchmakerdata() const;
  private:
  bool _internal_has_matchmakerdata() const;
  public:
  void clear_matchmakerdata();
  const std::string& matchmakerdata() const;
  void set_matchmakerdata(const std::string& value);
  void set_matchmakerdata(std::string&& value);
  void set_matchmakerdata(const char* value);
  void set_matchmakerdata(const char* value, size_t size);
  std::string* mutable_matchmakerdata();
  std::string* release_matchmakerdata();
  void set_allocated_matchmakerdata(std::string* matchmakerdata);
  private:
  const std::string& _internal_matchmakerdata() const;
  void _internal_set_matchmakerdata(const std::string& value);
  std::string* _internal_mutable_matchmakerdata();
  public:

  // optional string dnsName = 11;
  bool has_dnsname() const;
  private:
  bool _internal_has_dnsname() const;
  public:
  void clear_dnsname();
  const std::string& dnsname() const;
  void set_dnsname(const std::string& value);
  void set_dnsname(std::string&& value);
  void set_dnsname(const char* value);
  void set_dnsname(const char* value, size_t size);
  std::string* mutable_dnsname();
  std::string* release_dnsname();
  void set_allocated_dnsname(std::string* dnsname);
  private:
  const std::string& _internal_dnsname() const;
  void _internal_set_dnsname(const std::string& value);
  std::string* _internal_mutable_dnsname();
  public:

  // optional int32 maxPlayers = 4 [default = 0];
  bool has_maxplayers() const;
  private:
  bool _internal_has_maxplayers() const;
  public:
  void clear_maxplayers();
  ::PROTOBUF_NAMESPACE_ID::int32 maxplayers() const;
  void set_maxplayers(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_maxplayers() const;
  void _internal_set_maxplayers(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool joinable = 5 [default = false];
  bool has_joinable() const;
  private:
  bool _internal_has_joinable() const;
  public:
  void clear_joinable();
  bool joinable() const;
  void set_joinable(bool value);
  private:
  bool _internal_joinable() const;
  void _internal_set_joinable(bool value);
  public:

  // optional int32 port = 7 [default = 0];
  bool has_port() const;
  private:
  bool _internal_has_port() const;
  public:
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::int32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_port() const;
  void _internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:com.amazon.whitewater.auxproxy.pbuffer.GameSession)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::amazon::whitewater::auxproxy::pbuffer::GameProperty > gameproperties_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gamesessionid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fleetid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ipaddress_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gamesessiondata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr matchmakerdata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dnsname_;
  ::PROTOBUF_NAMESPACE_ID::int32 maxplayers_;
  bool joinable_;
  ::PROTOBUF_NAMESPACE_ID::int32 port_;
  friend struct ::TableStruct_sdk_2eproto;
};
// -------------------------------------------------------------------

class AttributeValue_SDMEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AttributeValue_SDMEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AttributeValue_SDMEntry_DoNotUse, 
    std::string, double,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> SuperType;
  AttributeValue_SDMEntry_DoNotUse();
  explicit AttributeValue_SDMEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const AttributeValue_SDMEntry_DoNotUse& other);
  static const AttributeValue_SDMEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const AttributeValue_SDMEntry_DoNotUse*>(&_AttributeValue_SDMEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "com.amazon.whitewater.auxproxy.pbuffer.AttributeValue.SDMEntry.key");
#else
    (void) s;
#endif
    return true;
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sdk_2eproto);
    return ::descriptor_table_sdk_2eproto.file_level_metadata[3];
  }

  public:
};

// -------------------------------------------------------------------

class AttributeValue PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.amazon.whitewater.auxproxy.pbuffer.AttributeValue) */ {
 public:
  inline AttributeValue() : AttributeValue(nullptr) {}
  virtual ~AttributeValue();

  AttributeValue(const AttributeValue& from);
  AttributeValue(AttributeValue&& from) noexcept
    : AttributeValue() {
    *this = ::std::move(from);
  }

  inline AttributeValue& operator=(const AttributeValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttributeValue& operator=(AttributeValue&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AttributeValue& default_instance();

  static inline const AttributeValue* internal_default_instance() {
    return reinterpret_cast<const AttributeValue*>(
               &_AttributeValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AttributeValue& a, AttributeValue& b) {
    a.Swap(&b);
  }
  inline void Swap(AttributeValue* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AttributeValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AttributeValue* New() const final {
    return CreateMaybeMessage<AttributeValue>(nullptr);
  }

  AttributeValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AttributeValue>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AttributeValue& from);
  void MergeFrom(const AttributeValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AttributeValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.amazon.whitewater.auxproxy.pbuffer.AttributeValue";
  }
  protected:
  explicit AttributeValue(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sdk_2eproto);
    return ::descriptor_table_sdk_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSLFieldNumber = 4,
    kSDMFieldNumber = 5,
    kSFieldNumber = 2,
    kNFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // repeated string SL = 4;
  int sl_size() const;
  private:
  int _internal_sl_size() const;
  public:
  void clear_sl();
  const std::string& sl(int index) const;
  std::string* mutable_sl(int index);
  void set_sl(int index, const std::string& value);
  void set_sl(int index, std::string&& value);
  void set_sl(int index, const char* value);
  void set_sl(int index, const char* value, size_t size);
  std::string* add_sl();
  void add_sl(const std::string& value);
  void add_sl(std::string&& value);
  void add_sl(const char* value);
  void add_sl(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& sl() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_sl();
  private:
  const std::string& _internal_sl(int index) const;
  std::string* _internal_add_sl();
  public:

  // map<string, double> SDM = 5;
  int sdm_size() const;
  private:
  int _internal_sdm_size() const;
  public:
  void clear_sdm();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      _internal_sdm() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      _internal_mutable_sdm();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
      sdm() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
      mutable_sdm();

  // optional string S = 2;
  bool has_s() const;
  private:
  bool _internal_has_s() const;
  public:
  void clear_s();
  const std::string& s() const;
  void set_s(const std::string& value);
  void set_s(std::string&& value);
  void set_s(const char* value);
  void set_s(const char* value, size_t size);
  std::string* mutable_s();
  std::string* release_s();
  void set_allocated_s(std::string* s);
  private:
  const std::string& _internal_s() const;
  void _internal_set_s(const std::string& value);
  std::string* _internal_mutable_s();
  public:

  // optional double N = 3 [default = 0];
  bool has_n() const;
  private:
  bool _internal_has_n() const;
  public:
  void clear_n();
  double n() const;
  void set_n(double value);
  private:
  double _internal_n() const;
  void _internal_set_n(double value);
  public:

  // optional int32 type = 1 [default = 0];
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::int32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_type() const;
  void _internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:com.amazon.whitewater.auxproxy.pbuffer.AttributeValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> sl_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      AttributeValue_SDMEntry_DoNotUse,
      std::string, double,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_DOUBLE> sdm_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s_;
  double n_;
  ::PROTOBUF_NAMESPACE_ID::int32 type_;
  friend struct ::TableStruct_sdk_2eproto;
};
// -------------------------------------------------------------------

class Player_PlayerAttributesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Player_PlayerAttributesEntry_DoNotUse, 
    std::string, ::com::amazon::whitewater::auxproxy::pbuffer::AttributeValue,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Player_PlayerAttributesEntry_DoNotUse, 
    std::string, ::com::amazon::whitewater::auxproxy::pbuffer::AttributeValue,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Player_PlayerAttributesEntry_DoNotUse();
  explicit Player_PlayerAttributesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Player_PlayerAttributesEntry_DoNotUse& other);
  static const Player_PlayerAttributesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Player_PlayerAttributesEntry_DoNotUse*>(&_Player_PlayerAttributesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "com.amazon.whitewater.auxproxy.pbuffer.Player.PlayerAttributesEntry.key");
#else
    (void) s;
#endif
    return true;
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sdk_2eproto);
    return ::descriptor_table_sdk_2eproto.file_level_metadata[5];
  }

  public:
};

// -------------------------------------------------------------------

class Player_LatencyInMsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Player_LatencyInMsEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::int32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Player_LatencyInMsEntry_DoNotUse, 
    std::string, ::PROTOBUF_NAMESPACE_ID::int32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> SuperType;
  Player_LatencyInMsEntry_DoNotUse();
  explicit Player_LatencyInMsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Player_LatencyInMsEntry_DoNotUse& other);
  static const Player_LatencyInMsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Player_LatencyInMsEntry_DoNotUse*>(&_Player_LatencyInMsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
#ifndef NDEBUG
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
       s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "com.amazon.whitewater.auxproxy.pbuffer.Player.LatencyInMsEntry.key");
#else
    (void) s;
#endif
    return true;
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sdk_2eproto);
    return ::descriptor_table_sdk_2eproto.file_level_metadata[6];
  }

  public:
};

// -------------------------------------------------------------------

class Player PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.amazon.whitewater.auxproxy.pbuffer.Player) */ {
 public:
  inline Player() : Player(nullptr) {}
  virtual ~Player();

  Player(const Player& from);
  Player(Player&& from) noexcept
    : Player() {
    *this = ::std::move(from);
  }

  inline Player& operator=(const Player& from) {
    CopyFrom(from);
    return *this;
  }
  inline Player& operator=(Player&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Player& default_instance();

  static inline const Player* internal_default_instance() {
    return reinterpret_cast<const Player*>(
               &_Player_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Player& a, Player& b) {
    a.Swap(&b);
  }
  inline void Swap(Player* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Player* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Player* New() const final {
    return CreateMaybeMessage<Player>(nullptr);
  }

  Player* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Player>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Player& from);
  void MergeFrom(const Player& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Player* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.amazon.whitewater.auxproxy.pbuffer.Player";
  }
  protected:
  explicit Player(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sdk_2eproto);
    return ::descriptor_table_sdk_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kPlayerAttributesFieldNumber = 2,
    kLatencyInMsFieldNumber = 4,
    kPlayerIdFieldNumber = 1,
    kTeamFieldNumber = 3,
  };
  // map<string, .com.amazon.whitewater.auxproxy.pbuffer.AttributeValue> playerAttributes = 2;
  int playerattributes_size() const;
  private:
  int _internal_playerattributes_size() const;
  public:
  void clear_playerattributes();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::com::amazon::whitewater::auxproxy::pbuffer::AttributeValue >&
      _internal_playerattributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::com::amazon::whitewater::auxproxy::pbuffer::AttributeValue >*
      _internal_mutable_playerattributes();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::com::amazon::whitewater::auxproxy::pbuffer::AttributeValue >&
      playerattributes() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::com::amazon::whitewater::auxproxy::pbuffer::AttributeValue >*
      mutable_playerattributes();

  // map<string, int32> latencyInMs = 4;
  int latencyinms_size() const;
  private:
  int _internal_latencyinms_size() const;
  public:
  void clear_latencyinms();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_latencyinms() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_latencyinms();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int32 >&
      latencyinms() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_latencyinms();

  // optional string playerId = 1;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  const std::string& playerid() const;
  void set_playerid(const std::string& value);
  void set_playerid(std::string&& value);
  void set_playerid(const char* value);
  void set_playerid(const char* value, size_t size);
  std::string* mutable_playerid();
  std::string* release_playerid();
  void set_allocated_playerid(std::string* playerid);
  private:
  const std::string& _internal_playerid() const;
  void _internal_set_playerid(const std::string& value);
  std::string* _internal_mutable_playerid();
  public:

  // optional string team = 3;
  bool has_team() const;
  private:
  bool _internal_has_team() const;
  public:
  void clear_team();
  const std::string& team() const;
  void set_team(const std::string& value);
  void set_team(std::string&& value);
  void set_team(const char* value);
  void set_team(const char* value, size_t size);
  std::string* mutable_team();
  std::string* release_team();
  void set_allocated_team(std::string* team);
  private:
  const std::string& _internal_team() const;
  void _internal_set_team(const std::string& value);
  std::string* _internal_mutable_team();
  public:

  // @@protoc_insertion_point(class_scope:com.amazon.whitewater.auxproxy.pbuffer.Player)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Player_PlayerAttributesEntry_DoNotUse,
      std::string, ::com::amazon::whitewater::auxproxy::pbuffer::AttributeValue,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> playerattributes_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Player_LatencyInMsEntry_DoNotUse,
      std::string, ::PROTOBUF_NAMESPACE_ID::int32,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> latencyinms_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr playerid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr team_;
  friend struct ::TableStruct_sdk_2eproto;
};
// -------------------------------------------------------------------

class PlayerSession PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession) */ {
 public:
  inline PlayerSession() : PlayerSession(nullptr) {}
  virtual ~PlayerSession();

  PlayerSession(const PlayerSession& from);
  PlayerSession(PlayerSession&& from) noexcept
    : PlayerSession() {
    *this = ::std::move(from);
  }

  inline PlayerSession& operator=(const PlayerSession& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerSession& operator=(PlayerSession&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlayerSession& default_instance();

  static inline const PlayerSession* internal_default_instance() {
    return reinterpret_cast<const PlayerSession*>(
               &_PlayerSession_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PlayerSession& a, PlayerSession& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerSession* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerSession* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerSession* New() const final {
    return CreateMaybeMessage<PlayerSession>(nullptr);
  }

  PlayerSession* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerSession>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlayerSession& from);
  void MergeFrom(const PlayerSession& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerSession* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.amazon.whitewater.auxproxy.pbuffer.PlayerSession";
  }
  protected:
  explicit PlayerSession(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sdk_2eproto);
    return ::descriptor_table_sdk_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerSessionIdFieldNumber = 1,
    kPlayerIdFieldNumber = 2,
    kGameSessionIdFieldNumber = 3,
    kFleetIdFieldNumber = 4,
    kIpAddressFieldNumber = 5,
    kStatusFieldNumber = 6,
    kPlayerDataFieldNumber = 10,
    kDnsNameFieldNumber = 11,
    kCreationTimeFieldNumber = 7,
    kTerminationTimeFieldNumber = 8,
    kPortFieldNumber = 9,
  };
  // optional string playerSessionId = 1;
  bool has_playersessionid() const;
  private:
  bool _internal_has_playersessionid() const;
  public:
  void clear_playersessionid();
  const std::string& playersessionid() const;
  void set_playersessionid(const std::string& value);
  void set_playersessionid(std::string&& value);
  void set_playersessionid(const char* value);
  void set_playersessionid(const char* value, size_t size);
  std::string* mutable_playersessionid();
  std::string* release_playersessionid();
  void set_allocated_playersessionid(std::string* playersessionid);
  private:
  const std::string& _internal_playersessionid() const;
  void _internal_set_playersessionid(const std::string& value);
  std::string* _internal_mutable_playersessionid();
  public:

  // optional string playerId = 2;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  const std::string& playerid() const;
  void set_playerid(const std::string& value);
  void set_playerid(std::string&& value);
  void set_playerid(const char* value);
  void set_playerid(const char* value, size_t size);
  std::string* mutable_playerid();
  std::string* release_playerid();
  void set_allocated_playerid(std::string* playerid);
  private:
  const std::string& _internal_playerid() const;
  void _internal_set_playerid(const std::string& value);
  std::string* _internal_mutable_playerid();
  public:

  // optional string gameSessionId = 3;
  bool has_gamesessionid() const;
  private:
  bool _internal_has_gamesessionid() const;
  public:
  void clear_gamesessionid();
  const std::string& gamesessionid() const;
  void set_gamesessionid(const std::string& value);
  void set_gamesessionid(std::string&& value);
  void set_gamesessionid(const char* value);
  void set_gamesessionid(const char* value, size_t size);
  std::string* mutable_gamesessionid();
  std::string* release_gamesessionid();
  void set_allocated_gamesessionid(std::string* gamesessionid);
  private:
  const std::string& _internal_gamesessionid() const;
  void _internal_set_gamesessionid(const std::string& value);
  std::string* _internal_mutable_gamesessionid();
  public:

  // optional string fleetId = 4;
  bool has_fleetid() const;
  private:
  bool _internal_has_fleetid() const;
  public:
  void clear_fleetid();
  const std::string& fleetid() const;
  void set_fleetid(const std::string& value);
  void set_fleetid(std::string&& value);
  void set_fleetid(const char* value);
  void set_fleetid(const char* value, size_t size);
  std::string* mutable_fleetid();
  std::string* release_fleetid();
  void set_allocated_fleetid(std::string* fleetid);
  private:
  const std::string& _internal_fleetid() const;
  void _internal_set_fleetid(const std::string& value);
  std::string* _internal_mutable_fleetid();
  public:

  // optional string ipAddress = 5;
  bool has_ipaddress() const;
  private:
  bool _internal_has_ipaddress() const;
  public:
  void clear_ipaddress();
  const std::string& ipaddress() const;
  void set_ipaddress(const std::string& value);
  void set_ipaddress(std::string&& value);
  void set_ipaddress(const char* value);
  void set_ipaddress(const char* value, size_t size);
  std::string* mutable_ipaddress();
  std::string* release_ipaddress();
  void set_allocated_ipaddress(std::string* ipaddress);
  private:
  const std::string& _internal_ipaddress() const;
  void _internal_set_ipaddress(const std::string& value);
  std::string* _internal_mutable_ipaddress();
  public:

  // optional string status = 6;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const std::string& status() const;
  void set_status(const std::string& value);
  void set_status(std::string&& value);
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  std::string* mutable_status();
  std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // optional string playerData = 10;
  bool has_playerdata() const;
  private:
  bool _internal_has_playerdata() const;
  public:
  void clear_playerdata();
  const std::string& playerdata() const;
  void set_playerdata(const std::string& value);
  void set_playerdata(std::string&& value);
  void set_playerdata(const char* value);
  void set_playerdata(const char* value, size_t size);
  std::string* mutable_playerdata();
  std::string* release_playerdata();
  void set_allocated_playerdata(std::string* playerdata);
  private:
  const std::string& _internal_playerdata() const;
  void _internal_set_playerdata(const std::string& value);
  std::string* _internal_mutable_playerdata();
  public:

  // optional string dnsName = 11;
  bool has_dnsname() const;
  private:
  bool _internal_has_dnsname() const;
  public:
  void clear_dnsname();
  const std::string& dnsname() const;
  void set_dnsname(const std::string& value);
  void set_dnsname(std::string&& value);
  void set_dnsname(const char* value);
  void set_dnsname(const char* value, size_t size);
  std::string* mutable_dnsname();
  std::string* release_dnsname();
  void set_allocated_dnsname(std::string* dnsname);
  private:
  const std::string& _internal_dnsname() const;
  void _internal_set_dnsname(const std::string& value);
  std::string* _internal_mutable_dnsname();
  public:

  // optional int64 creationTime = 7 [default = 0];
  bool has_creationtime() const;
  private:
  bool _internal_has_creationtime() const;
  public:
  void clear_creationtime();
  ::PROTOBUF_NAMESPACE_ID::int64 creationtime() const;
  void set_creationtime(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_creationtime() const;
  void _internal_set_creationtime(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 terminationTime = 8 [default = 0];
  bool has_terminationtime() const;
  private:
  bool _internal_has_terminationtime() const;
  public:
  void clear_terminationtime();
  ::PROTOBUF_NAMESPACE_ID::int64 terminationtime() const;
  void set_terminationtime(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_terminationtime() const;
  void _internal_set_terminationtime(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int32 port = 9 [default = 0];
  bool has_port() const;
  private:
  bool _internal_has_port() const;
  public:
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::int32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_port() const;
  void _internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr playersessionid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr playerid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gamesessionid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fleetid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ipaddress_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr playerdata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dnsname_;
  ::PROTOBUF_NAMESPACE_ID::int64 creationtime_;
  ::PROTOBUF_NAMESPACE_ID::int64 terminationtime_;
  ::PROTOBUF_NAMESPACE_ID::int32 port_;
  friend struct ::TableStruct_sdk_2eproto;
};
// -------------------------------------------------------------------

class UpdateGameSession PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.amazon.whitewater.auxproxy.pbuffer.UpdateGameSession) */ {
 public:
  inline UpdateGameSession() : UpdateGameSession(nullptr) {}
  virtual ~UpdateGameSession();

  UpdateGameSession(const UpdateGameSession& from);
  UpdateGameSession(UpdateGameSession&& from) noexcept
    : UpdateGameSession() {
    *this = ::std::move(from);
  }

  inline UpdateGameSession& operator=(const UpdateGameSession& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateGameSession& operator=(UpdateGameSession&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UpdateGameSession& default_instance();

  static inline const UpdateGameSession* internal_default_instance() {
    return reinterpret_cast<const UpdateGameSession*>(
               &_UpdateGameSession_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(UpdateGameSession& a, UpdateGameSession& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateGameSession* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateGameSession* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdateGameSession* New() const final {
    return CreateMaybeMessage<UpdateGameSession>(nullptr);
  }

  UpdateGameSession* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdateGameSession>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UpdateGameSession& from);
  void MergeFrom(const UpdateGameSession& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateGameSession* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.amazon.whitewater.auxproxy.pbuffer.UpdateGameSession";
  }
  protected:
  explicit UpdateGameSession(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sdk_2eproto);
    return ::descriptor_table_sdk_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUpdateReasonFieldNumber = 2,
    kBackfillTicketIdFieldNumber = 3,
    kGameSessionFieldNumber = 1,
  };
  // optional string updateReason = 2;
  bool has_updatereason() const;
  private:
  bool _internal_has_updatereason() const;
  public:
  void clear_updatereason();
  const std::string& updatereason() const;
  void set_updatereason(const std::string& value);
  void set_updatereason(std::string&& value);
  void set_updatereason(const char* value);
  void set_updatereason(const char* value, size_t size);
  std::string* mutable_updatereason();
  std::string* release_updatereason();
  void set_allocated_updatereason(std::string* updatereason);
  private:
  const std::string& _internal_updatereason() const;
  void _internal_set_updatereason(const std::string& value);
  std::string* _internal_mutable_updatereason();
  public:

  // optional string backfillTicketId = 3;
  bool has_backfillticketid() const;
  private:
  bool _internal_has_backfillticketid() const;
  public:
  void clear_backfillticketid();
  const std::string& backfillticketid() const;
  void set_backfillticketid(const std::string& value);
  void set_backfillticketid(std::string&& value);
  void set_backfillticketid(const char* value);
  void set_backfillticketid(const char* value, size_t size);
  std::string* mutable_backfillticketid();
  std::string* release_backfillticketid();
  void set_allocated_backfillticketid(std::string* backfillticketid);
  private:
  const std::string& _internal_backfillticketid() const;
  void _internal_set_backfillticketid(const std::string& value);
  std::string* _internal_mutable_backfillticketid();
  public:

  // optional .com.amazon.whitewater.auxproxy.pbuffer.GameSession gameSession = 1;
  bool has_gamesession() const;
  private:
  bool _internal_has_gamesession() const;
  public:
  void clear_gamesession();
  const ::com::amazon::whitewater::auxproxy::pbuffer::GameSession& gamesession() const;
  ::com::amazon::whitewater::auxproxy::pbuffer::GameSession* release_gamesession();
  ::com::amazon::whitewater::auxproxy::pbuffer::GameSession* mutable_gamesession();
  void set_allocated_gamesession(::com::amazon::whitewater::auxproxy::pbuffer::GameSession* gamesession);
  private:
  const ::com::amazon::whitewater::auxproxy::pbuffer::GameSession& _internal_gamesession() const;
  ::com::amazon::whitewater::auxproxy::pbuffer::GameSession* _internal_mutable_gamesession();
  public:
  void unsafe_arena_set_allocated_gamesession(
      ::com::amazon::whitewater::auxproxy::pbuffer::GameSession* gamesession);
  ::com::amazon::whitewater::auxproxy::pbuffer::GameSession* unsafe_arena_release_gamesession();

  // @@protoc_insertion_point(class_scope:com.amazon.whitewater.auxproxy.pbuffer.UpdateGameSession)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr updatereason_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr backfillticketid_;
  ::com::amazon::whitewater::auxproxy::pbuffer::GameSession* gamesession_;
  friend struct ::TableStruct_sdk_2eproto;
};
// -------------------------------------------------------------------

class TerminateProcess PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.amazon.whitewater.auxproxy.pbuffer.TerminateProcess) */ {
 public:
  inline TerminateProcess() : TerminateProcess(nullptr) {}
  virtual ~TerminateProcess();

  TerminateProcess(const TerminateProcess& from);
  TerminateProcess(TerminateProcess&& from) noexcept
    : TerminateProcess() {
    *this = ::std::move(from);
  }

  inline TerminateProcess& operator=(const TerminateProcess& from) {
    CopyFrom(from);
    return *this;
  }
  inline TerminateProcess& operator=(TerminateProcess&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TerminateProcess& default_instance();

  static inline const TerminateProcess* internal_default_instance() {
    return reinterpret_cast<const TerminateProcess*>(
               &_TerminateProcess_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TerminateProcess& a, TerminateProcess& b) {
    a.Swap(&b);
  }
  inline void Swap(TerminateProcess* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TerminateProcess* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TerminateProcess* New() const final {
    return CreateMaybeMessage<TerminateProcess>(nullptr);
  }

  TerminateProcess* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TerminateProcess>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TerminateProcess& from);
  void MergeFrom(const TerminateProcess& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TerminateProcess* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.amazon.whitewater.auxproxy.pbuffer.TerminateProcess";
  }
  protected:
  explicit TerminateProcess(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sdk_2eproto);
    return ::descriptor_table_sdk_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTerminationTimeFieldNumber = 1,
  };
  // optional int64 terminationTime = 1 [default = 0];
  bool has_terminationtime() const;
  private:
  bool _internal_has_terminationtime() const;
  public:
  void clear_terminationtime();
  ::PROTOBUF_NAMESPACE_ID::int64 terminationtime() const;
  void set_terminationtime(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_terminationtime() const;
  void _internal_set_terminationtime(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:com.amazon.whitewater.auxproxy.pbuffer.TerminateProcess)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 terminationtime_;
  friend struct ::TableStruct_sdk_2eproto;
};
// -------------------------------------------------------------------

class ActivateGameSession PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.amazon.whitewater.auxproxy.pbuffer.ActivateGameSession) */ {
 public:
  inline ActivateGameSession() : ActivateGameSession(nullptr) {}
  virtual ~ActivateGameSession();

  ActivateGameSession(const ActivateGameSession& from);
  ActivateGameSession(ActivateGameSession&& from) noexcept
    : ActivateGameSession() {
    *this = ::std::move(from);
  }

  inline ActivateGameSession& operator=(const ActivateGameSession& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActivateGameSession& operator=(ActivateGameSession&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ActivateGameSession& default_instance();

  static inline const ActivateGameSession* internal_default_instance() {
    return reinterpret_cast<const ActivateGameSession*>(
               &_ActivateGameSession_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ActivateGameSession& a, ActivateGameSession& b) {
    a.Swap(&b);
  }
  inline void Swap(ActivateGameSession* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActivateGameSession* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ActivateGameSession* New() const final {
    return CreateMaybeMessage<ActivateGameSession>(nullptr);
  }

  ActivateGameSession* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ActivateGameSession>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ActivateGameSession& from);
  void MergeFrom(const ActivateGameSession& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActivateGameSession* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.amazon.whitewater.auxproxy.pbuffer.ActivateGameSession";
  }
  protected:
  explicit ActivateGameSession(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sdk_2eproto);
    return ::descriptor_table_sdk_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameSessionFieldNumber = 1,
  };
  // optional .com.amazon.whitewater.auxproxy.pbuffer.GameSession gameSession = 1;
  bool has_gamesession() const;
  private:
  bool _internal_has_gamesession() const;
  public:
  void clear_gamesession();
  const ::com::amazon::whitewater::auxproxy::pbuffer::GameSession& gamesession() const;
  ::com::amazon::whitewater::auxproxy::pbuffer::GameSession* release_gamesession();
  ::com::amazon::whitewater::auxproxy::pbuffer::GameSession* mutable_gamesession();
  void set_allocated_gamesession(::com::amazon::whitewater::auxproxy::pbuffer::GameSession* gamesession);
  private:
  const ::com::amazon::whitewater::auxproxy::pbuffer::GameSession& _internal_gamesession() const;
  ::com::amazon::whitewater::auxproxy::pbuffer::GameSession* _internal_mutable_gamesession();
  public:
  void unsafe_arena_set_allocated_gamesession(
      ::com::amazon::whitewater::auxproxy::pbuffer::GameSession* gamesession);
  ::com::amazon::whitewater::auxproxy::pbuffer::GameSession* unsafe_arena_release_gamesession();

  // @@protoc_insertion_point(class_scope:com.amazon.whitewater.auxproxy.pbuffer.ActivateGameSession)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::com::amazon::whitewater::auxproxy::pbuffer::GameSession* gamesession_;
  friend struct ::TableStruct_sdk_2eproto;
};
// -------------------------------------------------------------------

class ProcessReady PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.amazon.whitewater.auxproxy.pbuffer.ProcessReady) */ {
 public:
  inline ProcessReady() : ProcessReady(nullptr) {}
  virtual ~ProcessReady();

  ProcessReady(const ProcessReady& from);
  ProcessReady(ProcessReady&& from) noexcept
    : ProcessReady() {
    *this = ::std::move(from);
  }

  inline ProcessReady& operator=(const ProcessReady& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessReady& operator=(ProcessReady&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ProcessReady& default_instance();

  static inline const ProcessReady* internal_default_instance() {
    return reinterpret_cast<const ProcessReady*>(
               &_ProcessReady_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ProcessReady& a, ProcessReady& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessReady* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessReady* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProcessReady* New() const final {
    return CreateMaybeMessage<ProcessReady>(nullptr);
  }

  ProcessReady* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProcessReady>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ProcessReady& from);
  void MergeFrom(const ProcessReady& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessReady* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.amazon.whitewater.auxproxy.pbuffer.ProcessReady";
  }
  protected:
  explicit ProcessReady(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sdk_2eproto);
    return ::descriptor_table_sdk_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogPathsToUploadFieldNumber = 1,
    kPortFieldNumber = 2,
  };
  // repeated string logPathsToUpload = 1;
  int logpathstoupload_size() const;
  private:
  int _internal_logpathstoupload_size() const;
  public:
  void clear_logpathstoupload();
  const std::string& logpathstoupload(int index) const;
  std::string* mutable_logpathstoupload(int index);
  void set_logpathstoupload(int index, const std::string& value);
  void set_logpathstoupload(int index, std::string&& value);
  void set_logpathstoupload(int index, const char* value);
  void set_logpathstoupload(int index, const char* value, size_t size);
  std::string* add_logpathstoupload();
  void add_logpathstoupload(const std::string& value);
  void add_logpathstoupload(std::string&& value);
  void add_logpathstoupload(const char* value);
  void add_logpathstoupload(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& logpathstoupload() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_logpathstoupload();
  private:
  const std::string& _internal_logpathstoupload(int index) const;
  std::string* _internal_add_logpathstoupload();
  public:

  // optional int32 port = 2 [default = 0];
  bool has_port() const;
  private:
  bool _internal_has_port() const;
  public:
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::int32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_port() const;
  void _internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:com.amazon.whitewater.auxproxy.pbuffer.ProcessReady)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> logpathstoupload_;
  ::PROTOBUF_NAMESPACE_ID::int32 port_;
  friend struct ::TableStruct_sdk_2eproto;
};
// -------------------------------------------------------------------

class ProcessEnding PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.amazon.whitewater.auxproxy.pbuffer.ProcessEnding) */ {
 public:
  inline ProcessEnding() : ProcessEnding(nullptr) {}
  virtual ~ProcessEnding();

  ProcessEnding(const ProcessEnding& from);
  ProcessEnding(ProcessEnding&& from) noexcept
    : ProcessEnding() {
    *this = ::std::move(from);
  }

  inline ProcessEnding& operator=(const ProcessEnding& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessEnding& operator=(ProcessEnding&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ProcessEnding& default_instance();

  static inline const ProcessEnding* internal_default_instance() {
    return reinterpret_cast<const ProcessEnding*>(
               &_ProcessEnding_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ProcessEnding& a, ProcessEnding& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcessEnding* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessEnding* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProcessEnding* New() const final {
    return CreateMaybeMessage<ProcessEnding>(nullptr);
  }

  ProcessEnding* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProcessEnding>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ProcessEnding& from);
  void MergeFrom(const ProcessEnding& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcessEnding* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.amazon.whitewater.auxproxy.pbuffer.ProcessEnding";
  }
  protected:
  explicit ProcessEnding(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sdk_2eproto);
    return ::descriptor_table_sdk_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:com.amazon.whitewater.auxproxy.pbuffer.ProcessEnding)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sdk_2eproto;
};
// -------------------------------------------------------------------

class ReportHealth PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.amazon.whitewater.auxproxy.pbuffer.ReportHealth) */ {
 public:
  inline ReportHealth() : ReportHealth(nullptr) {}
  virtual ~ReportHealth();

  ReportHealth(const ReportHealth& from);
  ReportHealth(ReportHealth&& from) noexcept
    : ReportHealth() {
    *this = ::std::move(from);
  }

  inline ReportHealth& operator=(const ReportHealth& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReportHealth& operator=(ReportHealth&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReportHealth& default_instance();

  static inline const ReportHealth* internal_default_instance() {
    return reinterpret_cast<const ReportHealth*>(
               &_ReportHealth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ReportHealth& a, ReportHealth& b) {
    a.Swap(&b);
  }
  inline void Swap(ReportHealth* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReportHealth* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReportHealth* New() const final {
    return CreateMaybeMessage<ReportHealth>(nullptr);
  }

  ReportHealth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReportHealth>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReportHealth& from);
  void MergeFrom(const ReportHealth& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReportHealth* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.amazon.whitewater.auxproxy.pbuffer.ReportHealth";
  }
  protected:
  explicit ReportHealth(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sdk_2eproto);
    return ::descriptor_table_sdk_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHealthStatusFieldNumber = 1,
  };
  // required bool healthStatus = 1;
  bool has_healthstatus() const;
  private:
  bool _internal_has_healthstatus() const;
  public:
  void clear_healthstatus();
  bool healthstatus() const;
  void set_healthstatus(bool value);
  private:
  bool _internal_healthstatus() const;
  void _internal_set_healthstatus(bool value);
  public:

  // @@protoc_insertion_point(class_scope:com.amazon.whitewater.auxproxy.pbuffer.ReportHealth)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool healthstatus_;
  friend struct ::TableStruct_sdk_2eproto;
};
// -------------------------------------------------------------------

class GameSessionActivate PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.amazon.whitewater.auxproxy.pbuffer.GameSessionActivate) */ {
 public:
  inline GameSessionActivate() : GameSessionActivate(nullptr) {}
  virtual ~GameSessionActivate();

  GameSessionActivate(const GameSessionActivate& from);
  GameSessionActivate(GameSessionActivate&& from) noexcept
    : GameSessionActivate() {
    *this = ::std::move(from);
  }

  inline GameSessionActivate& operator=(const GameSessionActivate& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameSessionActivate& operator=(GameSessionActivate&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameSessionActivate& default_instance();

  static inline const GameSessionActivate* internal_default_instance() {
    return reinterpret_cast<const GameSessionActivate*>(
               &_GameSessionActivate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GameSessionActivate& a, GameSessionActivate& b) {
    a.Swap(&b);
  }
  inline void Swap(GameSessionActivate* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameSessionActivate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameSessionActivate* New() const final {
    return CreateMaybeMessage<GameSessionActivate>(nullptr);
  }

  GameSessionActivate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameSessionActivate>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameSessionActivate& from);
  void MergeFrom(const GameSessionActivate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameSessionActivate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.amazon.whitewater.auxproxy.pbuffer.GameSessionActivate";
  }
  protected:
  explicit GameSessionActivate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sdk_2eproto);
    return ::descriptor_table_sdk_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameSessionIdFieldNumber = 1,
    kMaxPlayersFieldNumber = 2,
  };
  // optional string gameSessionId = 1;
  bool has_gamesessionid() const;
  private:
  bool _internal_has_gamesessionid() const;
  public:
  void clear_gamesessionid();
  const std::string& gamesessionid() const;
  void set_gamesessionid(const std::string& value);
  void set_gamesessionid(std::string&& value);
  void set_gamesessionid(const char* value);
  void set_gamesessionid(const char* value, size_t size);
  std::string* mutable_gamesessionid();
  std::string* release_gamesessionid();
  void set_allocated_gamesessionid(std::string* gamesessionid);
  private:
  const std::string& _internal_gamesessionid() const;
  void _internal_set_gamesessionid(const std::string& value);
  std::string* _internal_mutable_gamesessionid();
  public:

  // optional int32 maxPlayers = 2 [default = 0];
  bool has_maxplayers() const;
  private:
  bool _internal_has_maxplayers() const;
  public:
  void clear_maxplayers();
  ::PROTOBUF_NAMESPACE_ID::int32 maxplayers() const;
  void set_maxplayers(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_maxplayers() const;
  void _internal_set_maxplayers(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:com.amazon.whitewater.auxproxy.pbuffer.GameSessionActivate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gamesessionid_;
  ::PROTOBUF_NAMESPACE_ID::int32 maxplayers_;
  friend struct ::TableStruct_sdk_2eproto;
};
// -------------------------------------------------------------------

class GameSessionTerminate PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.amazon.whitewater.auxproxy.pbuffer.GameSessionTerminate) */ {
 public:
  inline GameSessionTerminate() : GameSessionTerminate(nullptr) {}
  virtual ~GameSessionTerminate();

  GameSessionTerminate(const GameSessionTerminate& from);
  GameSessionTerminate(GameSessionTerminate&& from) noexcept
    : GameSessionTerminate() {
    *this = ::std::move(from);
  }

  inline GameSessionTerminate& operator=(const GameSessionTerminate& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameSessionTerminate& operator=(GameSessionTerminate&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameSessionTerminate& default_instance();

  static inline const GameSessionTerminate* internal_default_instance() {
    return reinterpret_cast<const GameSessionTerminate*>(
               &_GameSessionTerminate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GameSessionTerminate& a, GameSessionTerminate& b) {
    a.Swap(&b);
  }
  inline void Swap(GameSessionTerminate* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameSessionTerminate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameSessionTerminate* New() const final {
    return CreateMaybeMessage<GameSessionTerminate>(nullptr);
  }

  GameSessionTerminate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameSessionTerminate>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameSessionTerminate& from);
  void MergeFrom(const GameSessionTerminate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameSessionTerminate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.amazon.whitewater.auxproxy.pbuffer.GameSessionTerminate";
  }
  protected:
  explicit GameSessionTerminate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sdk_2eproto);
    return ::descriptor_table_sdk_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameSessionIdFieldNumber = 1,
  };
  // optional string gameSessionId = 1;
  bool has_gamesessionid() const;
  private:
  bool _internal_has_gamesessionid() const;
  public:
  void clear_gamesessionid();
  const std::string& gamesessionid() const;
  void set_gamesessionid(const std::string& value);
  void set_gamesessionid(std::string&& value);
  void set_gamesessionid(const char* value);
  void set_gamesessionid(const char* value, size_t size);
  std::string* mutable_gamesessionid();
  std::string* release_gamesessionid();
  void set_allocated_gamesessionid(std::string* gamesessionid);
  private:
  const std::string& _internal_gamesessionid() const;
  void _internal_set_gamesessionid(const std::string& value);
  std::string* _internal_mutable_gamesessionid();
  public:

  // @@protoc_insertion_point(class_scope:com.amazon.whitewater.auxproxy.pbuffer.GameSessionTerminate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gamesessionid_;
  friend struct ::TableStruct_sdk_2eproto;
};
// -------------------------------------------------------------------

class UpdatePlayerSessionCreationPolicy PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.amazon.whitewater.auxproxy.pbuffer.UpdatePlayerSessionCreationPolicy) */ {
 public:
  inline UpdatePlayerSessionCreationPolicy() : UpdatePlayerSessionCreationPolicy(nullptr) {}
  virtual ~UpdatePlayerSessionCreationPolicy();

  UpdatePlayerSessionCreationPolicy(const UpdatePlayerSessionCreationPolicy& from);
  UpdatePlayerSessionCreationPolicy(UpdatePlayerSessionCreationPolicy&& from) noexcept
    : UpdatePlayerSessionCreationPolicy() {
    *this = ::std::move(from);
  }

  inline UpdatePlayerSessionCreationPolicy& operator=(const UpdatePlayerSessionCreationPolicy& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdatePlayerSessionCreationPolicy& operator=(UpdatePlayerSessionCreationPolicy&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UpdatePlayerSessionCreationPolicy& default_instance();

  static inline const UpdatePlayerSessionCreationPolicy* internal_default_instance() {
    return reinterpret_cast<const UpdatePlayerSessionCreationPolicy*>(
               &_UpdatePlayerSessionCreationPolicy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(UpdatePlayerSessionCreationPolicy& a, UpdatePlayerSessionCreationPolicy& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdatePlayerSessionCreationPolicy* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdatePlayerSessionCreationPolicy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UpdatePlayerSessionCreationPolicy* New() const final {
    return CreateMaybeMessage<UpdatePlayerSessionCreationPolicy>(nullptr);
  }

  UpdatePlayerSessionCreationPolicy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UpdatePlayerSessionCreationPolicy>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UpdatePlayerSessionCreationPolicy& from);
  void MergeFrom(const UpdatePlayerSessionCreationPolicy& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdatePlayerSessionCreationPolicy* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.amazon.whitewater.auxproxy.pbuffer.UpdatePlayerSessionCreationPolicy";
  }
  protected:
  explicit UpdatePlayerSessionCreationPolicy(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sdk_2eproto);
    return ::descriptor_table_sdk_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameSessionIdFieldNumber = 1,
    kNewPlayerSessionCreationPolicyFieldNumber = 2,
  };
  // optional string gameSessionId = 1;
  bool has_gamesessionid() const;
  private:
  bool _internal_has_gamesessionid() const;
  public:
  void clear_gamesessionid();
  const std::string& gamesessionid() const;
  void set_gamesessionid(const std::string& value);
  void set_gamesessionid(std::string&& value);
  void set_gamesessionid(const char* value);
  void set_gamesessionid(const char* value, size_t size);
  std::string* mutable_gamesessionid();
  std::string* release_gamesessionid();
  void set_allocated_gamesessionid(std::string* gamesessionid);
  private:
  const std::string& _internal_gamesessionid() const;
  void _internal_set_gamesessionid(const std::string& value);
  std::string* _internal_mutable_gamesessionid();
  public:

  // optional string newPlayerSessionCreationPolicy = 2;
  bool has_newplayersessioncreationpolicy() const;
  private:
  bool _internal_has_newplayersessioncreationpolicy() const;
  public:
  void clear_newplayersessioncreationpolicy();
  const std::string& newplayersessioncreationpolicy() const;
  void set_newplayersessioncreationpolicy(const std::string& value);
  void set_newplayersessioncreationpolicy(std::string&& value);
  void set_newplayersessioncreationpolicy(const char* value);
  void set_newplayersessioncreationpolicy(const char* value, size_t size);
  std::string* mutable_newplayersessioncreationpolicy();
  std::string* release_newplayersessioncreationpolicy();
  void set_allocated_newplayersessioncreationpolicy(std::string* newplayersessioncreationpolicy);
  private:
  const std::string& _internal_newplayersessioncreationpolicy() const;
  void _internal_set_newplayersessioncreationpolicy(const std::string& value);
  std::string* _internal_mutable_newplayersessioncreationpolicy();
  public:

  // @@protoc_insertion_point(class_scope:com.amazon.whitewater.auxproxy.pbuffer.UpdatePlayerSessionCreationPolicy)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gamesessionid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr newplayersessioncreationpolicy_;
  friend struct ::TableStruct_sdk_2eproto;
};
// -------------------------------------------------------------------

class AcceptPlayerSession PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.amazon.whitewater.auxproxy.pbuffer.AcceptPlayerSession) */ {
 public:
  inline AcceptPlayerSession() : AcceptPlayerSession(nullptr) {}
  virtual ~AcceptPlayerSession();

  AcceptPlayerSession(const AcceptPlayerSession& from);
  AcceptPlayerSession(AcceptPlayerSession&& from) noexcept
    : AcceptPlayerSession() {
    *this = ::std::move(from);
  }

  inline AcceptPlayerSession& operator=(const AcceptPlayerSession& from) {
    CopyFrom(from);
    return *this;
  }
  inline AcceptPlayerSession& operator=(AcceptPlayerSession&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AcceptPlayerSession& default_instance();

  static inline const AcceptPlayerSession* internal_default_instance() {
    return reinterpret_cast<const AcceptPlayerSession*>(
               &_AcceptPlayerSession_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(AcceptPlayerSession& a, AcceptPlayerSession& b) {
    a.Swap(&b);
  }
  inline void Swap(AcceptPlayerSession* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AcceptPlayerSession* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AcceptPlayerSession* New() const final {
    return CreateMaybeMessage<AcceptPlayerSession>(nullptr);
  }

  AcceptPlayerSession* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AcceptPlayerSession>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AcceptPlayerSession& from);
  void MergeFrom(const AcceptPlayerSession& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AcceptPlayerSession* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.amazon.whitewater.auxproxy.pbuffer.AcceptPlayerSession";
  }
  protected:
  explicit AcceptPlayerSession(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sdk_2eproto);
    return ::descriptor_table_sdk_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameSessionIdFieldNumber = 1,
    kPlayerSessionIdFieldNumber = 2,
  };
  // optional string gameSessionId = 1;
  bool has_gamesessionid() const;
  private:
  bool _internal_has_gamesessionid() const;
  public:
  void clear_gamesessionid();
  const std::string& gamesessionid() const;
  void set_gamesessionid(const std::string& value);
  void set_gamesessionid(std::string&& value);
  void set_gamesessionid(const char* value);
  void set_gamesessionid(const char* value, size_t size);
  std::string* mutable_gamesessionid();
  std::string* release_gamesessionid();
  void set_allocated_gamesessionid(std::string* gamesessionid);
  private:
  const std::string& _internal_gamesessionid() const;
  void _internal_set_gamesessionid(const std::string& value);
  std::string* _internal_mutable_gamesessionid();
  public:

  // optional string playerSessionId = 2;
  bool has_playersessionid() const;
  private:
  bool _internal_has_playersessionid() const;
  public:
  void clear_playersessionid();
  const std::string& playersessionid() const;
  void set_playersessionid(const std::string& value);
  void set_playersessionid(std::string&& value);
  void set_playersessionid(const char* value);
  void set_playersessionid(const char* value, size_t size);
  std::string* mutable_playersessionid();
  std::string* release_playersessionid();
  void set_allocated_playersessionid(std::string* playersessionid);
  private:
  const std::string& _internal_playersessionid() const;
  void _internal_set_playersessionid(const std::string& value);
  std::string* _internal_mutable_playersessionid();
  public:

  // @@protoc_insertion_point(class_scope:com.amazon.whitewater.auxproxy.pbuffer.AcceptPlayerSession)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gamesessionid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr playersessionid_;
  friend struct ::TableStruct_sdk_2eproto;
};
// -------------------------------------------------------------------

class RemovePlayerSession PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.amazon.whitewater.auxproxy.pbuffer.RemovePlayerSession) */ {
 public:
  inline RemovePlayerSession() : RemovePlayerSession(nullptr) {}
  virtual ~RemovePlayerSession();

  RemovePlayerSession(const RemovePlayerSession& from);
  RemovePlayerSession(RemovePlayerSession&& from) noexcept
    : RemovePlayerSession() {
    *this = ::std::move(from);
  }

  inline RemovePlayerSession& operator=(const RemovePlayerSession& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemovePlayerSession& operator=(RemovePlayerSession&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RemovePlayerSession& default_instance();

  static inline const RemovePlayerSession* internal_default_instance() {
    return reinterpret_cast<const RemovePlayerSession*>(
               &_RemovePlayerSession_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(RemovePlayerSession& a, RemovePlayerSession& b) {
    a.Swap(&b);
  }
  inline void Swap(RemovePlayerSession* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemovePlayerSession* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RemovePlayerSession* New() const final {
    return CreateMaybeMessage<RemovePlayerSession>(nullptr);
  }

  RemovePlayerSession* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RemovePlayerSession>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RemovePlayerSession& from);
  void MergeFrom(const RemovePlayerSession& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemovePlayerSession* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.amazon.whitewater.auxproxy.pbuffer.RemovePlayerSession";
  }
  protected:
  explicit RemovePlayerSession(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sdk_2eproto);
    return ::descriptor_table_sdk_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameSessionIdFieldNumber = 1,
    kPlayerSessionIdFieldNumber = 2,
  };
  // optional string gameSessionId = 1;
  bool has_gamesessionid() const;
  private:
  bool _internal_has_gamesessionid() const;
  public:
  void clear_gamesessionid();
  const std::string& gamesessionid() const;
  void set_gamesessionid(const std::string& value);
  void set_gamesessionid(std::string&& value);
  void set_gamesessionid(const char* value);
  void set_gamesessionid(const char* value, size_t size);
  std::string* mutable_gamesessionid();
  std::string* release_gamesessionid();
  void set_allocated_gamesessionid(std::string* gamesessionid);
  private:
  const std::string& _internal_gamesessionid() const;
  void _internal_set_gamesessionid(const std::string& value);
  std::string* _internal_mutable_gamesessionid();
  public:

  // optional string playerSessionId = 2;
  bool has_playersessionid() const;
  private:
  bool _internal_has_playersessionid() const;
  public:
  void clear_playersessionid();
  const std::string& playersessionid() const;
  void set_playersessionid(const std::string& value);
  void set_playersessionid(std::string&& value);
  void set_playersessionid(const char* value);
  void set_playersessionid(const char* value, size_t size);
  std::string* mutable_playersessionid();
  std::string* release_playersessionid();
  void set_allocated_playersessionid(std::string* playersessionid);
  private:
  const std::string& _internal_playersessionid() const;
  void _internal_set_playersessionid(const std::string& value);
  std::string* _internal_mutable_playersessionid();
  public:

  // @@protoc_insertion_point(class_scope:com.amazon.whitewater.auxproxy.pbuffer.RemovePlayerSession)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gamesessionid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr playersessionid_;
  friend struct ::TableStruct_sdk_2eproto;
};
// -------------------------------------------------------------------

class DescribePlayerSessionsRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest) */ {
 public:
  inline DescribePlayerSessionsRequest() : DescribePlayerSessionsRequest(nullptr) {}
  virtual ~DescribePlayerSessionsRequest();

  DescribePlayerSessionsRequest(const DescribePlayerSessionsRequest& from);
  DescribePlayerSessionsRequest(DescribePlayerSessionsRequest&& from) noexcept
    : DescribePlayerSessionsRequest() {
    *this = ::std::move(from);
  }

  inline DescribePlayerSessionsRequest& operator=(const DescribePlayerSessionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DescribePlayerSessionsRequest& operator=(DescribePlayerSessionsRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DescribePlayerSessionsRequest& default_instance();

  static inline const DescribePlayerSessionsRequest* internal_default_instance() {
    return reinterpret_cast<const DescribePlayerSessionsRequest*>(
               &_DescribePlayerSessionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(DescribePlayerSessionsRequest& a, DescribePlayerSessionsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DescribePlayerSessionsRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DescribePlayerSessionsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DescribePlayerSessionsRequest* New() const final {
    return CreateMaybeMessage<DescribePlayerSessionsRequest>(nullptr);
  }

  DescribePlayerSessionsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DescribePlayerSessionsRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DescribePlayerSessionsRequest& from);
  void MergeFrom(const DescribePlayerSessionsRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DescribePlayerSessionsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest";
  }
  protected:
  explicit DescribePlayerSessionsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sdk_2eproto);
    return ::descriptor_table_sdk_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameSessionIdFieldNumber = 1,
    kPlayerIdFieldNumber = 2,
    kPlayerSessionIdFieldNumber = 3,
    kPlayerSessionStatusFilterFieldNumber = 4,
    kNextTokenFieldNumber = 5,
    kLimitFieldNumber = 6,
  };
  // optional string gameSessionId = 1;
  bool has_gamesessionid() const;
  private:
  bool _internal_has_gamesessionid() const;
  public:
  void clear_gamesessionid();
  const std::string& gamesessionid() const;
  void set_gamesessionid(const std::string& value);
  void set_gamesessionid(std::string&& value);
  void set_gamesessionid(const char* value);
  void set_gamesessionid(const char* value, size_t size);
  std::string* mutable_gamesessionid();
  std::string* release_gamesessionid();
  void set_allocated_gamesessionid(std::string* gamesessionid);
  private:
  const std::string& _internal_gamesessionid() const;
  void _internal_set_gamesessionid(const std::string& value);
  std::string* _internal_mutable_gamesessionid();
  public:

  // optional string playerId = 2;
  bool has_playerid() const;
  private:
  bool _internal_has_playerid() const;
  public:
  void clear_playerid();
  const std::string& playerid() const;
  void set_playerid(const std::string& value);
  void set_playerid(std::string&& value);
  void set_playerid(const char* value);
  void set_playerid(const char* value, size_t size);
  std::string* mutable_playerid();
  std::string* release_playerid();
  void set_allocated_playerid(std::string* playerid);
  private:
  const std::string& _internal_playerid() const;
  void _internal_set_playerid(const std::string& value);
  std::string* _internal_mutable_playerid();
  public:

  // optional string playerSessionId = 3;
  bool has_playersessionid() const;
  private:
  bool _internal_has_playersessionid() const;
  public:
  void clear_playersessionid();
  const std::string& playersessionid() const;
  void set_playersessionid(const std::string& value);
  void set_playersessionid(std::string&& value);
  void set_playersessionid(const char* value);
  void set_playersessionid(const char* value, size_t size);
  std::string* mutable_playersessionid();
  std::string* release_playersessionid();
  void set_allocated_playersessionid(std::string* playersessionid);
  private:
  const std::string& _internal_playersessionid() const;
  void _internal_set_playersessionid(const std::string& value);
  std::string* _internal_mutable_playersessionid();
  public:

  // optional string playerSessionStatusFilter = 4;
  bool has_playersessionstatusfilter() const;
  private:
  bool _internal_has_playersessionstatusfilter() const;
  public:
  void clear_playersessionstatusfilter();
  const std::string& playersessionstatusfilter() const;
  void set_playersessionstatusfilter(const std::string& value);
  void set_playersessionstatusfilter(std::string&& value);
  void set_playersessionstatusfilter(const char* value);
  void set_playersessionstatusfilter(const char* value, size_t size);
  std::string* mutable_playersessionstatusfilter();
  std::string* release_playersessionstatusfilter();
  void set_allocated_playersessionstatusfilter(std::string* playersessionstatusfilter);
  private:
  const std::string& _internal_playersessionstatusfilter() const;
  void _internal_set_playersessionstatusfilter(const std::string& value);
  std::string* _internal_mutable_playersessionstatusfilter();
  public:

  // optional string nextToken = 5;
  bool has_nexttoken() const;
  private:
  bool _internal_has_nexttoken() const;
  public:
  void clear_nexttoken();
  const std::string& nexttoken() const;
  void set_nexttoken(const std::string& value);
  void set_nexttoken(std::string&& value);
  void set_nexttoken(const char* value);
  void set_nexttoken(const char* value, size_t size);
  std::string* mutable_nexttoken();
  std::string* release_nexttoken();
  void set_allocated_nexttoken(std::string* nexttoken);
  private:
  const std::string& _internal_nexttoken() const;
  void _internal_set_nexttoken(const std::string& value);
  std::string* _internal_mutable_nexttoken();
  public:

  // optional int32 limit = 6 [default = 0];
  bool has_limit() const;
  private:
  bool _internal_has_limit() const;
  public:
  void clear_limit();
  ::PROTOBUF_NAMESPACE_ID::int32 limit() const;
  void set_limit(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_limit() const;
  void _internal_set_limit(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gamesessionid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr playerid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr playersessionid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr playersessionstatusfilter_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nexttoken_;
  ::PROTOBUF_NAMESPACE_ID::int32 limit_;
  friend struct ::TableStruct_sdk_2eproto;
};
// -------------------------------------------------------------------

class BackfillMatchmakingRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.amazon.whitewater.auxproxy.pbuffer.BackfillMatchmakingRequest) */ {
 public:
  inline BackfillMatchmakingRequest() : BackfillMatchmakingRequest(nullptr) {}
  virtual ~BackfillMatchmakingRequest();

  BackfillMatchmakingRequest(const BackfillMatchmakingRequest& from);
  BackfillMatchmakingRequest(BackfillMatchmakingRequest&& from) noexcept
    : BackfillMatchmakingRequest() {
    *this = ::std::move(from);
  }

  inline BackfillMatchmakingRequest& operator=(const BackfillMatchmakingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BackfillMatchmakingRequest& operator=(BackfillMatchmakingRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BackfillMatchmakingRequest& default_instance();

  static inline const BackfillMatchmakingRequest* internal_default_instance() {
    return reinterpret_cast<const BackfillMatchmakingRequest*>(
               &_BackfillMatchmakingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(BackfillMatchmakingRequest& a, BackfillMatchmakingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BackfillMatchmakingRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BackfillMatchmakingRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BackfillMatchmakingRequest* New() const final {
    return CreateMaybeMessage<BackfillMatchmakingRequest>(nullptr);
  }

  BackfillMatchmakingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BackfillMatchmakingRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BackfillMatchmakingRequest& from);
  void MergeFrom(const BackfillMatchmakingRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BackfillMatchmakingRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.amazon.whitewater.auxproxy.pbuffer.BackfillMatchmakingRequest";
  }
  protected:
  explicit BackfillMatchmakingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sdk_2eproto);
    return ::descriptor_table_sdk_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 4,
    kTicketIdFieldNumber = 1,
    kGameSessionArnFieldNumber = 2,
    kMatchmakingConfigurationArnFieldNumber = 3,
  };
  // repeated .com.amazon.whitewater.auxproxy.pbuffer.Player players = 4;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::com::amazon::whitewater::auxproxy::pbuffer::Player* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::amazon::whitewater::auxproxy::pbuffer::Player >*
      mutable_players();
  private:
  const ::com::amazon::whitewater::auxproxy::pbuffer::Player& _internal_players(int index) const;
  ::com::amazon::whitewater::auxproxy::pbuffer::Player* _internal_add_players();
  public:
  const ::com::amazon::whitewater::auxproxy::pbuffer::Player& players(int index) const;
  ::com::amazon::whitewater::auxproxy::pbuffer::Player* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::amazon::whitewater::auxproxy::pbuffer::Player >&
      players() const;

  // optional string ticketId = 1;
  bool has_ticketid() const;
  private:
  bool _internal_has_ticketid() const;
  public:
  void clear_ticketid();
  const std::string& ticketid() const;
  void set_ticketid(const std::string& value);
  void set_ticketid(std::string&& value);
  void set_ticketid(const char* value);
  void set_ticketid(const char* value, size_t size);
  std::string* mutable_ticketid();
  std::string* release_ticketid();
  void set_allocated_ticketid(std::string* ticketid);
  private:
  const std::string& _internal_ticketid() const;
  void _internal_set_ticketid(const std::string& value);
  std::string* _internal_mutable_ticketid();
  public:

  // optional string gameSessionArn = 2;
  bool has_gamesessionarn() const;
  private:
  bool _internal_has_gamesessionarn() const;
  public:
  void clear_gamesessionarn();
  const std::string& gamesessionarn() const;
  void set_gamesessionarn(const std::string& value);
  void set_gamesessionarn(std::string&& value);
  void set_gamesessionarn(const char* value);
  void set_gamesessionarn(const char* value, size_t size);
  std::string* mutable_gamesessionarn();
  std::string* release_gamesessionarn();
  void set_allocated_gamesessionarn(std::string* gamesessionarn);
  private:
  const std::string& _internal_gamesessionarn() const;
  void _internal_set_gamesessionarn(const std::string& value);
  std::string* _internal_mutable_gamesessionarn();
  public:

  // optional string matchmakingConfigurationArn = 3;
  bool has_matchmakingconfigurationarn() const;
  private:
  bool _internal_has_matchmakingconfigurationarn() const;
  public:
  void clear_matchmakingconfigurationarn();
  const std::string& matchmakingconfigurationarn() const;
  void set_matchmakingconfigurationarn(const std::string& value);
  void set_matchmakingconfigurationarn(std::string&& value);
  void set_matchmakingconfigurationarn(const char* value);
  void set_matchmakingconfigurationarn(const char* value, size_t size);
  std::string* mutable_matchmakingconfigurationarn();
  std::string* release_matchmakingconfigurationarn();
  void set_allocated_matchmakingconfigurationarn(std::string* matchmakingconfigurationarn);
  private:
  const std::string& _internal_matchmakingconfigurationarn() const;
  void _internal_set_matchmakingconfigurationarn(const std::string& value);
  std::string* _internal_mutable_matchmakingconfigurationarn();
  public:

  // @@protoc_insertion_point(class_scope:com.amazon.whitewater.auxproxy.pbuffer.BackfillMatchmakingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::amazon::whitewater::auxproxy::pbuffer::Player > players_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ticketid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gamesessionarn_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr matchmakingconfigurationarn_;
  friend struct ::TableStruct_sdk_2eproto;
};
// -------------------------------------------------------------------

class StopMatchmakingRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.amazon.whitewater.auxproxy.pbuffer.StopMatchmakingRequest) */ {
 public:
  inline StopMatchmakingRequest() : StopMatchmakingRequest(nullptr) {}
  virtual ~StopMatchmakingRequest();

  StopMatchmakingRequest(const StopMatchmakingRequest& from);
  StopMatchmakingRequest(StopMatchmakingRequest&& from) noexcept
    : StopMatchmakingRequest() {
    *this = ::std::move(from);
  }

  inline StopMatchmakingRequest& operator=(const StopMatchmakingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopMatchmakingRequest& operator=(StopMatchmakingRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StopMatchmakingRequest& default_instance();

  static inline const StopMatchmakingRequest* internal_default_instance() {
    return reinterpret_cast<const StopMatchmakingRequest*>(
               &_StopMatchmakingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(StopMatchmakingRequest& a, StopMatchmakingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StopMatchmakingRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopMatchmakingRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StopMatchmakingRequest* New() const final {
    return CreateMaybeMessage<StopMatchmakingRequest>(nullptr);
  }

  StopMatchmakingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StopMatchmakingRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StopMatchmakingRequest& from);
  void MergeFrom(const StopMatchmakingRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopMatchmakingRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.amazon.whitewater.auxproxy.pbuffer.StopMatchmakingRequest";
  }
  protected:
  explicit StopMatchmakingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sdk_2eproto);
    return ::descriptor_table_sdk_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTicketIdFieldNumber = 1,
    kGameSessionArnFieldNumber = 2,
    kMatchmakingConfigurationArnFieldNumber = 3,
  };
  // optional string ticketId = 1;
  bool has_ticketid() const;
  private:
  bool _internal_has_ticketid() const;
  public:
  void clear_ticketid();
  const std::string& ticketid() const;
  void set_ticketid(const std::string& value);
  void set_ticketid(std::string&& value);
  void set_ticketid(const char* value);
  void set_ticketid(const char* value, size_t size);
  std::string* mutable_ticketid();
  std::string* release_ticketid();
  void set_allocated_ticketid(std::string* ticketid);
  private:
  const std::string& _internal_ticketid() const;
  void _internal_set_ticketid(const std::string& value);
  std::string* _internal_mutable_ticketid();
  public:

  // optional string gameSessionArn = 2;
  bool has_gamesessionarn() const;
  private:
  bool _internal_has_gamesessionarn() const;
  public:
  void clear_gamesessionarn();
  const std::string& gamesessionarn() const;
  void set_gamesessionarn(const std::string& value);
  void set_gamesessionarn(std::string&& value);
  void set_gamesessionarn(const char* value);
  void set_gamesessionarn(const char* value, size_t size);
  std::string* mutable_gamesessionarn();
  std::string* release_gamesessionarn();
  void set_allocated_gamesessionarn(std::string* gamesessionarn);
  private:
  const std::string& _internal_gamesessionarn() const;
  void _internal_set_gamesessionarn(const std::string& value);
  std::string* _internal_mutable_gamesessionarn();
  public:

  // optional string matchmakingConfigurationArn = 3;
  bool has_matchmakingconfigurationarn() const;
  private:
  bool _internal_has_matchmakingconfigurationarn() const;
  public:
  void clear_matchmakingconfigurationarn();
  const std::string& matchmakingconfigurationarn() const;
  void set_matchmakingconfigurationarn(const std::string& value);
  void set_matchmakingconfigurationarn(std::string&& value);
  void set_matchmakingconfigurationarn(const char* value);
  void set_matchmakingconfigurationarn(const char* value, size_t size);
  std::string* mutable_matchmakingconfigurationarn();
  std::string* release_matchmakingconfigurationarn();
  void set_allocated_matchmakingconfigurationarn(std::string* matchmakingconfigurationarn);
  private:
  const std::string& _internal_matchmakingconfigurationarn() const;
  void _internal_set_matchmakingconfigurationarn(const std::string& value);
  std::string* _internal_mutable_matchmakingconfigurationarn();
  public:

  // @@protoc_insertion_point(class_scope:com.amazon.whitewater.auxproxy.pbuffer.StopMatchmakingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ticketid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gamesessionarn_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr matchmakingconfigurationarn_;
  friend struct ::TableStruct_sdk_2eproto;
};
// -------------------------------------------------------------------

class GetInstanceCertificate PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.amazon.whitewater.auxproxy.pbuffer.GetInstanceCertificate) */ {
 public:
  inline GetInstanceCertificate() : GetInstanceCertificate(nullptr) {}
  virtual ~GetInstanceCertificate();

  GetInstanceCertificate(const GetInstanceCertificate& from);
  GetInstanceCertificate(GetInstanceCertificate&& from) noexcept
    : GetInstanceCertificate() {
    *this = ::std::move(from);
  }

  inline GetInstanceCertificate& operator=(const GetInstanceCertificate& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetInstanceCertificate& operator=(GetInstanceCertificate&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetInstanceCertificate& default_instance();

  static inline const GetInstanceCertificate* internal_default_instance() {
    return reinterpret_cast<const GetInstanceCertificate*>(
               &_GetInstanceCertificate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(GetInstanceCertificate& a, GetInstanceCertificate& b) {
    a.Swap(&b);
  }
  inline void Swap(GetInstanceCertificate* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetInstanceCertificate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetInstanceCertificate* New() const final {
    return CreateMaybeMessage<GetInstanceCertificate>(nullptr);
  }

  GetInstanceCertificate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetInstanceCertificate>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetInstanceCertificate& from);
  void MergeFrom(const GetInstanceCertificate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetInstanceCertificate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.amazon.whitewater.auxproxy.pbuffer.GetInstanceCertificate";
  }
  protected:
  explicit GetInstanceCertificate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sdk_2eproto);
    return ::descriptor_table_sdk_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:com.amazon.whitewater.auxproxy.pbuffer.GetInstanceCertificate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sdk_2eproto;
};
// -------------------------------------------------------------------

class BackfillMatchmakingResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.amazon.whitewater.auxproxy.pbuffer.BackfillMatchmakingResponse) */ {
 public:
  inline BackfillMatchmakingResponse() : BackfillMatchmakingResponse(nullptr) {}
  virtual ~BackfillMatchmakingResponse();

  BackfillMatchmakingResponse(const BackfillMatchmakingResponse& from);
  BackfillMatchmakingResponse(BackfillMatchmakingResponse&& from) noexcept
    : BackfillMatchmakingResponse() {
    *this = ::std::move(from);
  }

  inline BackfillMatchmakingResponse& operator=(const BackfillMatchmakingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BackfillMatchmakingResponse& operator=(BackfillMatchmakingResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BackfillMatchmakingResponse& default_instance();

  static inline const BackfillMatchmakingResponse* internal_default_instance() {
    return reinterpret_cast<const BackfillMatchmakingResponse*>(
               &_BackfillMatchmakingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(BackfillMatchmakingResponse& a, BackfillMatchmakingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BackfillMatchmakingResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BackfillMatchmakingResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BackfillMatchmakingResponse* New() const final {
    return CreateMaybeMessage<BackfillMatchmakingResponse>(nullptr);
  }

  BackfillMatchmakingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BackfillMatchmakingResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BackfillMatchmakingResponse& from);
  void MergeFrom(const BackfillMatchmakingResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BackfillMatchmakingResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.amazon.whitewater.auxproxy.pbuffer.BackfillMatchmakingResponse";
  }
  protected:
  explicit BackfillMatchmakingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sdk_2eproto);
    return ::descriptor_table_sdk_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTicketIdFieldNumber = 1,
  };
  // optional string ticketId = 1;
  bool has_ticketid() const;
  private:
  bool _internal_has_ticketid() const;
  public:
  void clear_ticketid();
  const std::string& ticketid() const;
  void set_ticketid(const std::string& value);
  void set_ticketid(std::string&& value);
  void set_ticketid(const char* value);
  void set_ticketid(const char* value, size_t size);
  std::string* mutable_ticketid();
  std::string* release_ticketid();
  void set_allocated_ticketid(std::string* ticketid);
  private:
  const std::string& _internal_ticketid() const;
  void _internal_set_ticketid(const std::string& value);
  std::string* _internal_mutable_ticketid();
  public:

  // @@protoc_insertion_point(class_scope:com.amazon.whitewater.auxproxy.pbuffer.BackfillMatchmakingResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ticketid_;
  friend struct ::TableStruct_sdk_2eproto;
};
// -------------------------------------------------------------------

class DescribePlayerSessionsResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsResponse) */ {
 public:
  inline DescribePlayerSessionsResponse() : DescribePlayerSessionsResponse(nullptr) {}
  virtual ~DescribePlayerSessionsResponse();

  DescribePlayerSessionsResponse(const DescribePlayerSessionsResponse& from);
  DescribePlayerSessionsResponse(DescribePlayerSessionsResponse&& from) noexcept
    : DescribePlayerSessionsResponse() {
    *this = ::std::move(from);
  }

  inline DescribePlayerSessionsResponse& operator=(const DescribePlayerSessionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DescribePlayerSessionsResponse& operator=(DescribePlayerSessionsResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DescribePlayerSessionsResponse& default_instance();

  static inline const DescribePlayerSessionsResponse* internal_default_instance() {
    return reinterpret_cast<const DescribePlayerSessionsResponse*>(
               &_DescribePlayerSessionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(DescribePlayerSessionsResponse& a, DescribePlayerSessionsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DescribePlayerSessionsResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DescribePlayerSessionsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DescribePlayerSessionsResponse* New() const final {
    return CreateMaybeMessage<DescribePlayerSessionsResponse>(nullptr);
  }

  DescribePlayerSessionsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DescribePlayerSessionsResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DescribePlayerSessionsResponse& from);
  void MergeFrom(const DescribePlayerSessionsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DescribePlayerSessionsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsResponse";
  }
  protected:
  explicit DescribePlayerSessionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sdk_2eproto);
    return ::descriptor_table_sdk_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerSessionsFieldNumber = 2,
    kNextTokenFieldNumber = 1,
  };
  // repeated .com.amazon.whitewater.auxproxy.pbuffer.PlayerSession playerSessions = 2;
  int playersessions_size() const;
  private:
  int _internal_playersessions_size() const;
  public:
  void clear_playersessions();
  ::com::amazon::whitewater::auxproxy::pbuffer::PlayerSession* mutable_playersessions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::amazon::whitewater::auxproxy::pbuffer::PlayerSession >*
      mutable_playersessions();
  private:
  const ::com::amazon::whitewater::auxproxy::pbuffer::PlayerSession& _internal_playersessions(int index) const;
  ::com::amazon::whitewater::auxproxy::pbuffer::PlayerSession* _internal_add_playersessions();
  public:
  const ::com::amazon::whitewater::auxproxy::pbuffer::PlayerSession& playersessions(int index) const;
  ::com::amazon::whitewater::auxproxy::pbuffer::PlayerSession* add_playersessions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::amazon::whitewater::auxproxy::pbuffer::PlayerSession >&
      playersessions() const;

  // optional string nextToken = 1;
  bool has_nexttoken() const;
  private:
  bool _internal_has_nexttoken() const;
  public:
  void clear_nexttoken();
  const std::string& nexttoken() const;
  void set_nexttoken(const std::string& value);
  void set_nexttoken(std::string&& value);
  void set_nexttoken(const char* value);
  void set_nexttoken(const char* value, size_t size);
  std::string* mutable_nexttoken();
  std::string* release_nexttoken();
  void set_allocated_nexttoken(std::string* nexttoken);
  private:
  const std::string& _internal_nexttoken() const;
  void _internal_set_nexttoken(const std::string& value);
  std::string* _internal_mutable_nexttoken();
  public:

  // @@protoc_insertion_point(class_scope:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::amazon::whitewater::auxproxy::pbuffer::PlayerSession > playersessions_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nexttoken_;
  friend struct ::TableStruct_sdk_2eproto;
};
// -------------------------------------------------------------------

class GetInstanceCertificateResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.amazon.whitewater.auxproxy.pbuffer.GetInstanceCertificateResponse) */ {
 public:
  inline GetInstanceCertificateResponse() : GetInstanceCertificateResponse(nullptr) {}
  virtual ~GetInstanceCertificateResponse();

  GetInstanceCertificateResponse(const GetInstanceCertificateResponse& from);
  GetInstanceCertificateResponse(GetInstanceCertificateResponse&& from) noexcept
    : GetInstanceCertificateResponse() {
    *this = ::std::move(from);
  }

  inline GetInstanceCertificateResponse& operator=(const GetInstanceCertificateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetInstanceCertificateResponse& operator=(GetInstanceCertificateResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetInstanceCertificateResponse& default_instance();

  static inline const GetInstanceCertificateResponse* internal_default_instance() {
    return reinterpret_cast<const GetInstanceCertificateResponse*>(
               &_GetInstanceCertificateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(GetInstanceCertificateResponse& a, GetInstanceCertificateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetInstanceCertificateResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetInstanceCertificateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetInstanceCertificateResponse* New() const final {
    return CreateMaybeMessage<GetInstanceCertificateResponse>(nullptr);
  }

  GetInstanceCertificateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetInstanceCertificateResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetInstanceCertificateResponse& from);
  void MergeFrom(const GetInstanceCertificateResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetInstanceCertificateResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.amazon.whitewater.auxproxy.pbuffer.GetInstanceCertificateResponse";
  }
  protected:
  explicit GetInstanceCertificateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sdk_2eproto);
    return ::descriptor_table_sdk_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCertificatePathFieldNumber = 1,
    kCertificateChainPathFieldNumber = 2,
    kPrivateKeyPathFieldNumber = 3,
    kHostNameFieldNumber = 4,
  };
  // optional string certificatePath = 1;
  bool has_certificatepath() const;
  private:
  bool _internal_has_certificatepath() const;
  public:
  void clear_certificatepath();
  const std::string& certificatepath() const;
  void set_certificatepath(const std::string& value);
  void set_certificatepath(std::string&& value);
  void set_certificatepath(const char* value);
  void set_certificatepath(const char* value, size_t size);
  std::string* mutable_certificatepath();
  std::string* release_certificatepath();
  void set_allocated_certificatepath(std::string* certificatepath);
  private:
  const std::string& _internal_certificatepath() const;
  void _internal_set_certificatepath(const std::string& value);
  std::string* _internal_mutable_certificatepath();
  public:

  // optional string certificateChainPath = 2;
  bool has_certificatechainpath() const;
  private:
  bool _internal_has_certificatechainpath() const;
  public:
  void clear_certificatechainpath();
  const std::string& certificatechainpath() const;
  void set_certificatechainpath(const std::string& value);
  void set_certificatechainpath(std::string&& value);
  void set_certificatechainpath(const char* value);
  void set_certificatechainpath(const char* value, size_t size);
  std::string* mutable_certificatechainpath();
  std::string* release_certificatechainpath();
  void set_allocated_certificatechainpath(std::string* certificatechainpath);
  private:
  const std::string& _internal_certificatechainpath() const;
  void _internal_set_certificatechainpath(const std::string& value);
  std::string* _internal_mutable_certificatechainpath();
  public:

  // optional string privateKeyPath = 3;
  bool has_privatekeypath() const;
  private:
  bool _internal_has_privatekeypath() const;
  public:
  void clear_privatekeypath();
  const std::string& privatekeypath() const;
  void set_privatekeypath(const std::string& value);
  void set_privatekeypath(std::string&& value);
  void set_privatekeypath(const char* value);
  void set_privatekeypath(const char* value, size_t size);
  std::string* mutable_privatekeypath();
  std::string* release_privatekeypath();
  void set_allocated_privatekeypath(std::string* privatekeypath);
  private:
  const std::string& _internal_privatekeypath() const;
  void _internal_set_privatekeypath(const std::string& value);
  std::string* _internal_mutable_privatekeypath();
  public:

  // optional string hostName = 4;
  bool has_hostname() const;
  private:
  bool _internal_has_hostname() const;
  public:
  void clear_hostname();
  const std::string& hostname() const;
  void set_hostname(const std::string& value);
  void set_hostname(std::string&& value);
  void set_hostname(const char* value);
  void set_hostname(const char* value, size_t size);
  std::string* mutable_hostname();
  std::string* release_hostname();
  void set_allocated_hostname(std::string* hostname);
  private:
  const std::string& _internal_hostname() const;
  void _internal_set_hostname(const std::string& value);
  std::string* _internal_mutable_hostname();
  public:

  // @@protoc_insertion_point(class_scope:com.amazon.whitewater.auxproxy.pbuffer.GetInstanceCertificateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr certificatepath_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr certificatechainpath_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr privatekeypath_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostname_;
  friend struct ::TableStruct_sdk_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GameLiftResponse

// optional .com.amazon.whitewater.auxproxy.pbuffer.GameLiftResponseStatus status = 1;
inline bool GameLiftResponse::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GameLiftResponse::has_status() const {
  return _internal_has_status();
}
inline void GameLiftResponse::clear_status() {
  status_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::com::amazon::whitewater::auxproxy::pbuffer::GameLiftResponseStatus GameLiftResponse::_internal_status() const {
  return static_cast< ::com::amazon::whitewater::auxproxy::pbuffer::GameLiftResponseStatus >(status_);
}
inline ::com::amazon::whitewater::auxproxy::pbuffer::GameLiftResponseStatus GameLiftResponse::status() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.GameLiftResponse.status)
  return _internal_status();
}
inline void GameLiftResponse::_internal_set_status(::com::amazon::whitewater::auxproxy::pbuffer::GameLiftResponseStatus value) {
  assert(::com::amazon::whitewater::auxproxy::pbuffer::GameLiftResponseStatus_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  status_ = value;
}
inline void GameLiftResponse::set_status(::com::amazon::whitewater::auxproxy::pbuffer::GameLiftResponseStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.GameLiftResponse.status)
}

// optional string responseData = 2;
inline bool GameLiftResponse::_internal_has_responsedata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GameLiftResponse::has_responsedata() const {
  return _internal_has_responsedata();
}
inline void GameLiftResponse::clear_responsedata() {
  responsedata_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GameLiftResponse::responsedata() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.GameLiftResponse.responseData)
  return _internal_responsedata();
}
inline void GameLiftResponse::set_responsedata(const std::string& value) {
  _internal_set_responsedata(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.GameLiftResponse.responseData)
}
inline std::string* GameLiftResponse::mutable_responsedata() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.GameLiftResponse.responseData)
  return _internal_mutable_responsedata();
}
inline const std::string& GameLiftResponse::_internal_responsedata() const {
  return responsedata_.Get();
}
inline void GameLiftResponse::_internal_set_responsedata(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  responsedata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void GameLiftResponse::set_responsedata(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  responsedata_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.GameLiftResponse.responseData)
}
inline void GameLiftResponse::set_responsedata(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  responsedata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.GameLiftResponse.responseData)
}
inline void GameLiftResponse::set_responsedata(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  responsedata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.GameLiftResponse.responseData)
}
inline std::string* GameLiftResponse::_internal_mutable_responsedata() {
  _has_bits_[0] |= 0x00000001u;
  return responsedata_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* GameLiftResponse::release_responsedata() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.GameLiftResponse.responseData)
  if (!_internal_has_responsedata()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return responsedata_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GameLiftResponse::set_allocated_responsedata(std::string* responsedata) {
  if (responsedata != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  responsedata_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), responsedata,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.GameLiftResponse.responseData)
}

// optional string errorMessage = 3;
inline bool GameLiftResponse::_internal_has_errormessage() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GameLiftResponse::has_errormessage() const {
  return _internal_has_errormessage();
}
inline void GameLiftResponse::clear_errormessage() {
  errormessage_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GameLiftResponse::errormessage() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.GameLiftResponse.errorMessage)
  return _internal_errormessage();
}
inline void GameLiftResponse::set_errormessage(const std::string& value) {
  _internal_set_errormessage(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.GameLiftResponse.errorMessage)
}
inline std::string* GameLiftResponse::mutable_errormessage() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.GameLiftResponse.errorMessage)
  return _internal_mutable_errormessage();
}
inline const std::string& GameLiftResponse::_internal_errormessage() const {
  return errormessage_.Get();
}
inline void GameLiftResponse::_internal_set_errormessage(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  errormessage_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void GameLiftResponse::set_errormessage(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  errormessage_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.GameLiftResponse.errorMessage)
}
inline void GameLiftResponse::set_errormessage(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  errormessage_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.GameLiftResponse.errorMessage)
}
inline void GameLiftResponse::set_errormessage(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  errormessage_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.GameLiftResponse.errorMessage)
}
inline std::string* GameLiftResponse::_internal_mutable_errormessage() {
  _has_bits_[0] |= 0x00000002u;
  return errormessage_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* GameLiftResponse::release_errormessage() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.GameLiftResponse.errorMessage)
  if (!_internal_has_errormessage()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return errormessage_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GameLiftResponse::set_allocated_errormessage(std::string* errormessage) {
  if (errormessage != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  errormessage_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), errormessage,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.GameLiftResponse.errorMessage)
}

// -------------------------------------------------------------------

// GameProperty

// optional string key = 1;
inline bool GameProperty::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GameProperty::has_key() const {
  return _internal_has_key();
}
inline void GameProperty::clear_key() {
  key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GameProperty::key() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.GameProperty.key)
  return _internal_key();
}
inline void GameProperty::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.GameProperty.key)
}
inline std::string* GameProperty::mutable_key() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.GameProperty.key)
  return _internal_mutable_key();
}
inline const std::string& GameProperty::_internal_key() const {
  return key_.Get();
}
inline void GameProperty::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void GameProperty::set_key(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.GameProperty.key)
}
inline void GameProperty::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.GameProperty.key)
}
inline void GameProperty::set_key(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.GameProperty.key)
}
inline std::string* GameProperty::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* GameProperty::release_key() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.GameProperty.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GameProperty::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.GameProperty.key)
}

// optional string value = 2;
inline bool GameProperty::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GameProperty::has_value() const {
  return _internal_has_value();
}
inline void GameProperty::clear_value() {
  value_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GameProperty::value() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.GameProperty.value)
  return _internal_value();
}
inline void GameProperty::set_value(const std::string& value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.GameProperty.value)
}
inline std::string* GameProperty::mutable_value() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.GameProperty.value)
  return _internal_mutable_value();
}
inline const std::string& GameProperty::_internal_value() const {
  return value_.Get();
}
inline void GameProperty::_internal_set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void GameProperty::set_value(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  value_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.GameProperty.value)
}
inline void GameProperty::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.GameProperty.value)
}
inline void GameProperty::set_value(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.GameProperty.value)
}
inline std::string* GameProperty::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000002u;
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* GameProperty::release_value() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.GameProperty.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GameProperty::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.GameProperty.value)
}

// -------------------------------------------------------------------

// GameSession

// optional string gameSessionId = 1;
inline bool GameSession::_internal_has_gamesessionid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GameSession::has_gamesessionid() const {
  return _internal_has_gamesessionid();
}
inline void GameSession::clear_gamesessionid() {
  gamesessionid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GameSession::gamesessionid() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.GameSession.gameSessionId)
  return _internal_gamesessionid();
}
inline void GameSession::set_gamesessionid(const std::string& value) {
  _internal_set_gamesessionid(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.GameSession.gameSessionId)
}
inline std::string* GameSession::mutable_gamesessionid() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.GameSession.gameSessionId)
  return _internal_mutable_gamesessionid();
}
inline const std::string& GameSession::_internal_gamesessionid() const {
  return gamesessionid_.Get();
}
inline void GameSession::_internal_set_gamesessionid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  gamesessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void GameSession::set_gamesessionid(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  gamesessionid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.GameSession.gameSessionId)
}
inline void GameSession::set_gamesessionid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  gamesessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.GameSession.gameSessionId)
}
inline void GameSession::set_gamesessionid(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  gamesessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.GameSession.gameSessionId)
}
inline std::string* GameSession::_internal_mutable_gamesessionid() {
  _has_bits_[0] |= 0x00000001u;
  return gamesessionid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* GameSession::release_gamesessionid() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.GameSession.gameSessionId)
  if (!_internal_has_gamesessionid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return gamesessionid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GameSession::set_allocated_gamesessionid(std::string* gamesessionid) {
  if (gamesessionid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  gamesessionid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gamesessionid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.GameSession.gameSessionId)
}

// optional string fleetId = 2;
inline bool GameSession::_internal_has_fleetid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GameSession::has_fleetid() const {
  return _internal_has_fleetid();
}
inline void GameSession::clear_fleetid() {
  fleetid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GameSession::fleetid() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.GameSession.fleetId)
  return _internal_fleetid();
}
inline void GameSession::set_fleetid(const std::string& value) {
  _internal_set_fleetid(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.GameSession.fleetId)
}
inline std::string* GameSession::mutable_fleetid() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.GameSession.fleetId)
  return _internal_mutable_fleetid();
}
inline const std::string& GameSession::_internal_fleetid() const {
  return fleetid_.Get();
}
inline void GameSession::_internal_set_fleetid(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  fleetid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void GameSession::set_fleetid(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  fleetid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.GameSession.fleetId)
}
inline void GameSession::set_fleetid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  fleetid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.GameSession.fleetId)
}
inline void GameSession::set_fleetid(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  fleetid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.GameSession.fleetId)
}
inline std::string* GameSession::_internal_mutable_fleetid() {
  _has_bits_[0] |= 0x00000002u;
  return fleetid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* GameSession::release_fleetid() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.GameSession.fleetId)
  if (!_internal_has_fleetid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return fleetid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GameSession::set_allocated_fleetid(std::string* fleetid) {
  if (fleetid != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  fleetid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fleetid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.GameSession.fleetId)
}

// optional string name = 3;
inline bool GameSession::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GameSession::has_name() const {
  return _internal_has_name();
}
inline void GameSession::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& GameSession::name() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.GameSession.name)
  return _internal_name();
}
inline void GameSession::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.GameSession.name)
}
inline std::string* GameSession::mutable_name() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.GameSession.name)
  return _internal_mutable_name();
}
inline const std::string& GameSession::_internal_name() const {
  return name_.Get();
}
inline void GameSession::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void GameSession::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.GameSession.name)
}
inline void GameSession::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.GameSession.name)
}
inline void GameSession::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.GameSession.name)
}
inline std::string* GameSession::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000004u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* GameSession::release_name() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.GameSession.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GameSession::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.GameSession.name)
}

// optional int32 maxPlayers = 4 [default = 0];
inline bool GameSession::_internal_has_maxplayers() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool GameSession::has_maxplayers() const {
  return _internal_has_maxplayers();
}
inline void GameSession::clear_maxplayers() {
  maxplayers_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameSession::_internal_maxplayers() const {
  return maxplayers_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameSession::maxplayers() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.GameSession.maxPlayers)
  return _internal_maxplayers();
}
inline void GameSession::_internal_set_maxplayers(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000080u;
  maxplayers_ = value;
}
inline void GameSession::set_maxplayers(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_maxplayers(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.GameSession.maxPlayers)
}

// optional bool joinable = 5 [default = false];
inline bool GameSession::_internal_has_joinable() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool GameSession::has_joinable() const {
  return _internal_has_joinable();
}
inline void GameSession::clear_joinable() {
  joinable_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool GameSession::_internal_joinable() const {
  return joinable_;
}
inline bool GameSession::joinable() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.GameSession.joinable)
  return _internal_joinable();
}
inline void GameSession::_internal_set_joinable(bool value) {
  _has_bits_[0] |= 0x00000100u;
  joinable_ = value;
}
inline void GameSession::set_joinable(bool value) {
  _internal_set_joinable(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.GameSession.joinable)
}

// repeated .com.amazon.whitewater.auxproxy.pbuffer.GameProperty gameProperties = 6;
inline int GameSession::_internal_gameproperties_size() const {
  return gameproperties_.size();
}
inline int GameSession::gameproperties_size() const {
  return _internal_gameproperties_size();
}
inline void GameSession::clear_gameproperties() {
  gameproperties_.Clear();
}
inline ::com::amazon::whitewater::auxproxy::pbuffer::GameProperty* GameSession::mutable_gameproperties(int index) {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.GameSession.gameProperties)
  return gameproperties_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::amazon::whitewater::auxproxy::pbuffer::GameProperty >*
GameSession::mutable_gameproperties() {
  // @@protoc_insertion_point(field_mutable_list:com.amazon.whitewater.auxproxy.pbuffer.GameSession.gameProperties)
  return &gameproperties_;
}
inline const ::com::amazon::whitewater::auxproxy::pbuffer::GameProperty& GameSession::_internal_gameproperties(int index) const {
  return gameproperties_.Get(index);
}
inline const ::com::amazon::whitewater::auxproxy::pbuffer::GameProperty& GameSession::gameproperties(int index) const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.GameSession.gameProperties)
  return _internal_gameproperties(index);
}
inline ::com::amazon::whitewater::auxproxy::pbuffer::GameProperty* GameSession::_internal_add_gameproperties() {
  return gameproperties_.Add();
}
inline ::com::amazon::whitewater::auxproxy::pbuffer::GameProperty* GameSession::add_gameproperties() {
  // @@protoc_insertion_point(field_add:com.amazon.whitewater.auxproxy.pbuffer.GameSession.gameProperties)
  return _internal_add_gameproperties();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::amazon::whitewater::auxproxy::pbuffer::GameProperty >&
GameSession::gameproperties() const {
  // @@protoc_insertion_point(field_list:com.amazon.whitewater.auxproxy.pbuffer.GameSession.gameProperties)
  return gameproperties_;
}

// optional int32 port = 7 [default = 0];
inline bool GameSession::_internal_has_port() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool GameSession::has_port() const {
  return _internal_has_port();
}
inline void GameSession::clear_port() {
  port_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameSession::_internal_port() const {
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameSession::port() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.GameSession.port)
  return _internal_port();
}
inline void GameSession::_internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000200u;
  port_ = value;
}
inline void GameSession::set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.GameSession.port)
}

// optional string ipAddress = 8;
inline bool GameSession::_internal_has_ipaddress() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GameSession::has_ipaddress() const {
  return _internal_has_ipaddress();
}
inline void GameSession::clear_ipaddress() {
  ipaddress_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& GameSession::ipaddress() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.GameSession.ipAddress)
  return _internal_ipaddress();
}
inline void GameSession::set_ipaddress(const std::string& value) {
  _internal_set_ipaddress(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.GameSession.ipAddress)
}
inline std::string* GameSession::mutable_ipaddress() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.GameSession.ipAddress)
  return _internal_mutable_ipaddress();
}
inline const std::string& GameSession::_internal_ipaddress() const {
  return ipaddress_.Get();
}
inline void GameSession::_internal_set_ipaddress(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  ipaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void GameSession::set_ipaddress(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  ipaddress_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.GameSession.ipAddress)
}
inline void GameSession::set_ipaddress(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  ipaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.GameSession.ipAddress)
}
inline void GameSession::set_ipaddress(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000008u;
  ipaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.GameSession.ipAddress)
}
inline std::string* GameSession::_internal_mutable_ipaddress() {
  _has_bits_[0] |= 0x00000008u;
  return ipaddress_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* GameSession::release_ipaddress() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.GameSession.ipAddress)
  if (!_internal_has_ipaddress()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return ipaddress_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GameSession::set_allocated_ipaddress(std::string* ipaddress) {
  if (ipaddress != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  ipaddress_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ipaddress,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.GameSession.ipAddress)
}

// optional string gameSessionData = 9;
inline bool GameSession::_internal_has_gamesessiondata() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool GameSession::has_gamesessiondata() const {
  return _internal_has_gamesessiondata();
}
inline void GameSession::clear_gamesessiondata() {
  gamesessiondata_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& GameSession::gamesessiondata() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.GameSession.gameSessionData)
  return _internal_gamesessiondata();
}
inline void GameSession::set_gamesessiondata(const std::string& value) {
  _internal_set_gamesessiondata(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.GameSession.gameSessionData)
}
inline std::string* GameSession::mutable_gamesessiondata() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.GameSession.gameSessionData)
  return _internal_mutable_gamesessiondata();
}
inline const std::string& GameSession::_internal_gamesessiondata() const {
  return gamesessiondata_.Get();
}
inline void GameSession::_internal_set_gamesessiondata(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  gamesessiondata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void GameSession::set_gamesessiondata(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  gamesessiondata_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.GameSession.gameSessionData)
}
inline void GameSession::set_gamesessiondata(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  gamesessiondata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.GameSession.gameSessionData)
}
inline void GameSession::set_gamesessiondata(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000010u;
  gamesessiondata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.GameSession.gameSessionData)
}
inline std::string* GameSession::_internal_mutable_gamesessiondata() {
  _has_bits_[0] |= 0x00000010u;
  return gamesessiondata_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* GameSession::release_gamesessiondata() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.GameSession.gameSessionData)
  if (!_internal_has_gamesessiondata()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return gamesessiondata_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GameSession::set_allocated_gamesessiondata(std::string* gamesessiondata) {
  if (gamesessiondata != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  gamesessiondata_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gamesessiondata,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.GameSession.gameSessionData)
}

// optional string matchmakerData = 10;
inline bool GameSession::_internal_has_matchmakerdata() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool GameSession::has_matchmakerdata() const {
  return _internal_has_matchmakerdata();
}
inline void GameSession::clear_matchmakerdata() {
  matchmakerdata_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& GameSession::matchmakerdata() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.GameSession.matchmakerData)
  return _internal_matchmakerdata();
}
inline void GameSession::set_matchmakerdata(const std::string& value) {
  _internal_set_matchmakerdata(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.GameSession.matchmakerData)
}
inline std::string* GameSession::mutable_matchmakerdata() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.GameSession.matchmakerData)
  return _internal_mutable_matchmakerdata();
}
inline const std::string& GameSession::_internal_matchmakerdata() const {
  return matchmakerdata_.Get();
}
inline void GameSession::_internal_set_matchmakerdata(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  matchmakerdata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void GameSession::set_matchmakerdata(std::string&& value) {
  _has_bits_[0] |= 0x00000020u;
  matchmakerdata_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.GameSession.matchmakerData)
}
inline void GameSession::set_matchmakerdata(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000020u;
  matchmakerdata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.GameSession.matchmakerData)
}
inline void GameSession::set_matchmakerdata(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000020u;
  matchmakerdata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.GameSession.matchmakerData)
}
inline std::string* GameSession::_internal_mutable_matchmakerdata() {
  _has_bits_[0] |= 0x00000020u;
  return matchmakerdata_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* GameSession::release_matchmakerdata() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.GameSession.matchmakerData)
  if (!_internal_has_matchmakerdata()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return matchmakerdata_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GameSession::set_allocated_matchmakerdata(std::string* matchmakerdata) {
  if (matchmakerdata != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  matchmakerdata_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), matchmakerdata,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.GameSession.matchmakerData)
}

// optional string dnsName = 11;
inline bool GameSession::_internal_has_dnsname() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool GameSession::has_dnsname() const {
  return _internal_has_dnsname();
}
inline void GameSession::clear_dnsname() {
  dnsname_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& GameSession::dnsname() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.GameSession.dnsName)
  return _internal_dnsname();
}
inline void GameSession::set_dnsname(const std::string& value) {
  _internal_set_dnsname(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.GameSession.dnsName)
}
inline std::string* GameSession::mutable_dnsname() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.GameSession.dnsName)
  return _internal_mutable_dnsname();
}
inline const std::string& GameSession::_internal_dnsname() const {
  return dnsname_.Get();
}
inline void GameSession::_internal_set_dnsname(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  dnsname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void GameSession::set_dnsname(std::string&& value) {
  _has_bits_[0] |= 0x00000040u;
  dnsname_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.GameSession.dnsName)
}
inline void GameSession::set_dnsname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000040u;
  dnsname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.GameSession.dnsName)
}
inline void GameSession::set_dnsname(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000040u;
  dnsname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.GameSession.dnsName)
}
inline std::string* GameSession::_internal_mutable_dnsname() {
  _has_bits_[0] |= 0x00000040u;
  return dnsname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* GameSession::release_dnsname() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.GameSession.dnsName)
  if (!_internal_has_dnsname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return dnsname_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GameSession::set_allocated_dnsname(std::string* dnsname) {
  if (dnsname != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  dnsname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), dnsname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.GameSession.dnsName)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// AttributeValue

// optional int32 type = 1 [default = 0];
inline bool AttributeValue::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AttributeValue::has_type() const {
  return _internal_has_type();
}
inline void AttributeValue::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AttributeValue::_internal_type() const {
  return type_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AttributeValue::type() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.AttributeValue.type)
  return _internal_type();
}
inline void AttributeValue::_internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  type_ = value;
}
inline void AttributeValue::set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.AttributeValue.type)
}

// optional string S = 2;
inline bool AttributeValue::_internal_has_s() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AttributeValue::has_s() const {
  return _internal_has_s();
}
inline void AttributeValue::clear_s() {
  s_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AttributeValue::s() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.AttributeValue.S)
  return _internal_s();
}
inline void AttributeValue::set_s(const std::string& value) {
  _internal_set_s(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.AttributeValue.S)
}
inline std::string* AttributeValue::mutable_s() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.AttributeValue.S)
  return _internal_mutable_s();
}
inline const std::string& AttributeValue::_internal_s() const {
  return s_.Get();
}
inline void AttributeValue::_internal_set_s(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  s_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void AttributeValue::set_s(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  s_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.AttributeValue.S)
}
inline void AttributeValue::set_s(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  s_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.AttributeValue.S)
}
inline void AttributeValue::set_s(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  s_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.AttributeValue.S)
}
inline std::string* AttributeValue::_internal_mutable_s() {
  _has_bits_[0] |= 0x00000001u;
  return s_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* AttributeValue::release_s() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.AttributeValue.S)
  if (!_internal_has_s()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return s_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AttributeValue::set_allocated_s(std::string* s) {
  if (s != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  s_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), s,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.AttributeValue.S)
}

// optional double N = 3 [default = 0];
inline bool AttributeValue::_internal_has_n() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AttributeValue::has_n() const {
  return _internal_has_n();
}
inline void AttributeValue::clear_n() {
  n_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double AttributeValue::_internal_n() const {
  return n_;
}
inline double AttributeValue::n() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.AttributeValue.N)
  return _internal_n();
}
inline void AttributeValue::_internal_set_n(double value) {
  _has_bits_[0] |= 0x00000002u;
  n_ = value;
}
inline void AttributeValue::set_n(double value) {
  _internal_set_n(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.AttributeValue.N)
}

// repeated string SL = 4;
inline int AttributeValue::_internal_sl_size() const {
  return sl_.size();
}
inline int AttributeValue::sl_size() const {
  return _internal_sl_size();
}
inline void AttributeValue::clear_sl() {
  sl_.Clear();
}
inline std::string* AttributeValue::add_sl() {
  // @@protoc_insertion_point(field_add_mutable:com.amazon.whitewater.auxproxy.pbuffer.AttributeValue.SL)
  return _internal_add_sl();
}
inline const std::string& AttributeValue::_internal_sl(int index) const {
  return sl_.Get(index);
}
inline const std::string& AttributeValue::sl(int index) const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.AttributeValue.SL)
  return _internal_sl(index);
}
inline std::string* AttributeValue::mutable_sl(int index) {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.AttributeValue.SL)
  return sl_.Mutable(index);
}
inline void AttributeValue::set_sl(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.AttributeValue.SL)
  sl_.Mutable(index)->assign(value);
}
inline void AttributeValue::set_sl(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.AttributeValue.SL)
  sl_.Mutable(index)->assign(std::move(value));
}
inline void AttributeValue::set_sl(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  sl_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.AttributeValue.SL)
}
inline void AttributeValue::set_sl(int index, const char* value, size_t size) {
  sl_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.AttributeValue.SL)
}
inline std::string* AttributeValue::_internal_add_sl() {
  return sl_.Add();
}
inline void AttributeValue::add_sl(const std::string& value) {
  sl_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:com.amazon.whitewater.auxproxy.pbuffer.AttributeValue.SL)
}
inline void AttributeValue::add_sl(std::string&& value) {
  sl_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:com.amazon.whitewater.auxproxy.pbuffer.AttributeValue.SL)
}
inline void AttributeValue::add_sl(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  sl_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:com.amazon.whitewater.auxproxy.pbuffer.AttributeValue.SL)
}
inline void AttributeValue::add_sl(const char* value, size_t size) {
  sl_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:com.amazon.whitewater.auxproxy.pbuffer.AttributeValue.SL)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AttributeValue::sl() const {
  // @@protoc_insertion_point(field_list:com.amazon.whitewater.auxproxy.pbuffer.AttributeValue.SL)
  return sl_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AttributeValue::mutable_sl() {
  // @@protoc_insertion_point(field_mutable_list:com.amazon.whitewater.auxproxy.pbuffer.AttributeValue.SL)
  return &sl_;
}

// map<string, double> SDM = 5;
inline int AttributeValue::_internal_sdm_size() const {
  return sdm_.size();
}
inline int AttributeValue::sdm_size() const {
  return _internal_sdm_size();
}
inline void AttributeValue::clear_sdm() {
  sdm_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
AttributeValue::_internal_sdm() const {
  return sdm_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >&
AttributeValue::sdm() const {
  // @@protoc_insertion_point(field_map:com.amazon.whitewater.auxproxy.pbuffer.AttributeValue.SDM)
  return _internal_sdm();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
AttributeValue::_internal_mutable_sdm() {
  return sdm_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, double >*
AttributeValue::mutable_sdm() {
  // @@protoc_insertion_point(field_mutable_map:com.amazon.whitewater.auxproxy.pbuffer.AttributeValue.SDM)
  return _internal_mutable_sdm();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Player

// optional string playerId = 1;
inline bool Player::_internal_has_playerid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Player::has_playerid() const {
  return _internal_has_playerid();
}
inline void Player::clear_playerid() {
  playerid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Player::playerid() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.Player.playerId)
  return _internal_playerid();
}
inline void Player::set_playerid(const std::string& value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.Player.playerId)
}
inline std::string* Player::mutable_playerid() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.Player.playerId)
  return _internal_mutable_playerid();
}
inline const std::string& Player::_internal_playerid() const {
  return playerid_.Get();
}
inline void Player::_internal_set_playerid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  playerid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Player::set_playerid(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  playerid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.Player.playerId)
}
inline void Player::set_playerid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  playerid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.Player.playerId)
}
inline void Player::set_playerid(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  playerid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.Player.playerId)
}
inline std::string* Player::_internal_mutable_playerid() {
  _has_bits_[0] |= 0x00000001u;
  return playerid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Player::release_playerid() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.Player.playerId)
  if (!_internal_has_playerid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return playerid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Player::set_allocated_playerid(std::string* playerid) {
  if (playerid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  playerid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), playerid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.Player.playerId)
}

// map<string, .com.amazon.whitewater.auxproxy.pbuffer.AttributeValue> playerAttributes = 2;
inline int Player::_internal_playerattributes_size() const {
  return playerattributes_.size();
}
inline int Player::playerattributes_size() const {
  return _internal_playerattributes_size();
}
inline void Player::clear_playerattributes() {
  playerattributes_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::com::amazon::whitewater::auxproxy::pbuffer::AttributeValue >&
Player::_internal_playerattributes() const {
  return playerattributes_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::com::amazon::whitewater::auxproxy::pbuffer::AttributeValue >&
Player::playerattributes() const {
  // @@protoc_insertion_point(field_map:com.amazon.whitewater.auxproxy.pbuffer.Player.playerAttributes)
  return _internal_playerattributes();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::com::amazon::whitewater::auxproxy::pbuffer::AttributeValue >*
Player::_internal_mutable_playerattributes() {
  return playerattributes_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::com::amazon::whitewater::auxproxy::pbuffer::AttributeValue >*
Player::mutable_playerattributes() {
  // @@protoc_insertion_point(field_mutable_map:com.amazon.whitewater.auxproxy.pbuffer.Player.playerAttributes)
  return _internal_mutable_playerattributes();
}

// optional string team = 3;
inline bool Player::_internal_has_team() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Player::has_team() const {
  return _internal_has_team();
}
inline void Player::clear_team() {
  team_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Player::team() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.Player.team)
  return _internal_team();
}
inline void Player::set_team(const std::string& value) {
  _internal_set_team(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.Player.team)
}
inline std::string* Player::mutable_team() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.Player.team)
  return _internal_mutable_team();
}
inline const std::string& Player::_internal_team() const {
  return team_.Get();
}
inline void Player::_internal_set_team(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  team_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Player::set_team(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  team_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.Player.team)
}
inline void Player::set_team(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  team_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.Player.team)
}
inline void Player::set_team(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  team_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.Player.team)
}
inline std::string* Player::_internal_mutable_team() {
  _has_bits_[0] |= 0x00000002u;
  return team_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Player::release_team() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.Player.team)
  if (!_internal_has_team()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return team_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Player::set_allocated_team(std::string* team) {
  if (team != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  team_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), team,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.Player.team)
}

// map<string, int32> latencyInMs = 4;
inline int Player::_internal_latencyinms_size() const {
  return latencyinms_.size();
}
inline int Player::latencyinms_size() const {
  return _internal_latencyinms_size();
}
inline void Player::clear_latencyinms() {
  latencyinms_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int32 >&
Player::_internal_latencyinms() const {
  return latencyinms_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int32 >&
Player::latencyinms() const {
  // @@protoc_insertion_point(field_map:com.amazon.whitewater.auxproxy.pbuffer.Player.latencyInMs)
  return _internal_latencyinms();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int32 >*
Player::_internal_mutable_latencyinms() {
  return latencyinms_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::PROTOBUF_NAMESPACE_ID::int32 >*
Player::mutable_latencyinms() {
  // @@protoc_insertion_point(field_mutable_map:com.amazon.whitewater.auxproxy.pbuffer.Player.latencyInMs)
  return _internal_mutable_latencyinms();
}

// -------------------------------------------------------------------

// PlayerSession

// optional string playerSessionId = 1;
inline bool PlayerSession::_internal_has_playersessionid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PlayerSession::has_playersessionid() const {
  return _internal_has_playersessionid();
}
inline void PlayerSession::clear_playersessionid() {
  playersessionid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PlayerSession::playersessionid() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.playerSessionId)
  return _internal_playersessionid();
}
inline void PlayerSession::set_playersessionid(const std::string& value) {
  _internal_set_playersessionid(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.playerSessionId)
}
inline std::string* PlayerSession::mutable_playersessionid() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.playerSessionId)
  return _internal_mutable_playersessionid();
}
inline const std::string& PlayerSession::_internal_playersessionid() const {
  return playersessionid_.Get();
}
inline void PlayerSession::_internal_set_playersessionid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  playersessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PlayerSession::set_playersessionid(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  playersessionid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.playerSessionId)
}
inline void PlayerSession::set_playersessionid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  playersessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.playerSessionId)
}
inline void PlayerSession::set_playersessionid(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  playersessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.playerSessionId)
}
inline std::string* PlayerSession::_internal_mutable_playersessionid() {
  _has_bits_[0] |= 0x00000001u;
  return playersessionid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PlayerSession::release_playersessionid() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.playerSessionId)
  if (!_internal_has_playersessionid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return playersessionid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PlayerSession::set_allocated_playersessionid(std::string* playersessionid) {
  if (playersessionid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  playersessionid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), playersessionid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.playerSessionId)
}

// optional string playerId = 2;
inline bool PlayerSession::_internal_has_playerid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PlayerSession::has_playerid() const {
  return _internal_has_playerid();
}
inline void PlayerSession::clear_playerid() {
  playerid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PlayerSession::playerid() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.playerId)
  return _internal_playerid();
}
inline void PlayerSession::set_playerid(const std::string& value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.playerId)
}
inline std::string* PlayerSession::mutable_playerid() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.playerId)
  return _internal_mutable_playerid();
}
inline const std::string& PlayerSession::_internal_playerid() const {
  return playerid_.Get();
}
inline void PlayerSession::_internal_set_playerid(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  playerid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PlayerSession::set_playerid(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  playerid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.playerId)
}
inline void PlayerSession::set_playerid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  playerid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.playerId)
}
inline void PlayerSession::set_playerid(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  playerid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.playerId)
}
inline std::string* PlayerSession::_internal_mutable_playerid() {
  _has_bits_[0] |= 0x00000002u;
  return playerid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PlayerSession::release_playerid() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.playerId)
  if (!_internal_has_playerid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return playerid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PlayerSession::set_allocated_playerid(std::string* playerid) {
  if (playerid != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  playerid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), playerid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.playerId)
}

// optional string gameSessionId = 3;
inline bool PlayerSession::_internal_has_gamesessionid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PlayerSession::has_gamesessionid() const {
  return _internal_has_gamesessionid();
}
inline void PlayerSession::clear_gamesessionid() {
  gamesessionid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PlayerSession::gamesessionid() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.gameSessionId)
  return _internal_gamesessionid();
}
inline void PlayerSession::set_gamesessionid(const std::string& value) {
  _internal_set_gamesessionid(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.gameSessionId)
}
inline std::string* PlayerSession::mutable_gamesessionid() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.gameSessionId)
  return _internal_mutable_gamesessionid();
}
inline const std::string& PlayerSession::_internal_gamesessionid() const {
  return gamesessionid_.Get();
}
inline void PlayerSession::_internal_set_gamesessionid(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  gamesessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PlayerSession::set_gamesessionid(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  gamesessionid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.gameSessionId)
}
inline void PlayerSession::set_gamesessionid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  gamesessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.gameSessionId)
}
inline void PlayerSession::set_gamesessionid(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  gamesessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.gameSessionId)
}
inline std::string* PlayerSession::_internal_mutable_gamesessionid() {
  _has_bits_[0] |= 0x00000004u;
  return gamesessionid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PlayerSession::release_gamesessionid() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.gameSessionId)
  if (!_internal_has_gamesessionid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return gamesessionid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PlayerSession::set_allocated_gamesessionid(std::string* gamesessionid) {
  if (gamesessionid != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  gamesessionid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gamesessionid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.gameSessionId)
}

// optional string fleetId = 4;
inline bool PlayerSession::_internal_has_fleetid() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PlayerSession::has_fleetid() const {
  return _internal_has_fleetid();
}
inline void PlayerSession::clear_fleetid() {
  fleetid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& PlayerSession::fleetid() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.fleetId)
  return _internal_fleetid();
}
inline void PlayerSession::set_fleetid(const std::string& value) {
  _internal_set_fleetid(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.fleetId)
}
inline std::string* PlayerSession::mutable_fleetid() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.fleetId)
  return _internal_mutable_fleetid();
}
inline const std::string& PlayerSession::_internal_fleetid() const {
  return fleetid_.Get();
}
inline void PlayerSession::_internal_set_fleetid(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  fleetid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PlayerSession::set_fleetid(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  fleetid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.fleetId)
}
inline void PlayerSession::set_fleetid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  fleetid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.fleetId)
}
inline void PlayerSession::set_fleetid(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000008u;
  fleetid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.fleetId)
}
inline std::string* PlayerSession::_internal_mutable_fleetid() {
  _has_bits_[0] |= 0x00000008u;
  return fleetid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PlayerSession::release_fleetid() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.fleetId)
  if (!_internal_has_fleetid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return fleetid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PlayerSession::set_allocated_fleetid(std::string* fleetid) {
  if (fleetid != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  fleetid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fleetid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.fleetId)
}

// optional string ipAddress = 5;
inline bool PlayerSession::_internal_has_ipaddress() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PlayerSession::has_ipaddress() const {
  return _internal_has_ipaddress();
}
inline void PlayerSession::clear_ipaddress() {
  ipaddress_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& PlayerSession::ipaddress() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.ipAddress)
  return _internal_ipaddress();
}
inline void PlayerSession::set_ipaddress(const std::string& value) {
  _internal_set_ipaddress(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.ipAddress)
}
inline std::string* PlayerSession::mutable_ipaddress() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.ipAddress)
  return _internal_mutable_ipaddress();
}
inline const std::string& PlayerSession::_internal_ipaddress() const {
  return ipaddress_.Get();
}
inline void PlayerSession::_internal_set_ipaddress(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  ipaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PlayerSession::set_ipaddress(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  ipaddress_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.ipAddress)
}
inline void PlayerSession::set_ipaddress(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  ipaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.ipAddress)
}
inline void PlayerSession::set_ipaddress(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000010u;
  ipaddress_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.ipAddress)
}
inline std::string* PlayerSession::_internal_mutable_ipaddress() {
  _has_bits_[0] |= 0x00000010u;
  return ipaddress_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PlayerSession::release_ipaddress() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.ipAddress)
  if (!_internal_has_ipaddress()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return ipaddress_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PlayerSession::set_allocated_ipaddress(std::string* ipaddress) {
  if (ipaddress != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  ipaddress_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ipaddress,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.ipAddress)
}

// optional string status = 6;
inline bool PlayerSession::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool PlayerSession::has_status() const {
  return _internal_has_status();
}
inline void PlayerSession::clear_status() {
  status_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& PlayerSession::status() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.status)
  return _internal_status();
}
inline void PlayerSession::set_status(const std::string& value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.status)
}
inline std::string* PlayerSession::mutable_status() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.status)
  return _internal_mutable_status();
}
inline const std::string& PlayerSession::_internal_status() const {
  return status_.Get();
}
inline void PlayerSession::_internal_set_status(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PlayerSession::set_status(std::string&& value) {
  _has_bits_[0] |= 0x00000020u;
  status_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.status)
}
inline void PlayerSession::set_status(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000020u;
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.status)
}
inline void PlayerSession::set_status(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000020u;
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.status)
}
inline std::string* PlayerSession::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000020u;
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PlayerSession::release_status() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.status)
  if (!_internal_has_status()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return status_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PlayerSession::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.status)
}

// optional int64 creationTime = 7 [default = 0];
inline bool PlayerSession::_internal_has_creationtime() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool PlayerSession::has_creationtime() const {
  return _internal_has_creationtime();
}
inline void PlayerSession::clear_creationtime() {
  creationtime_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PlayerSession::_internal_creationtime() const {
  return creationtime_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PlayerSession::creationtime() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.creationTime)
  return _internal_creationtime();
}
inline void PlayerSession::_internal_set_creationtime(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000100u;
  creationtime_ = value;
}
inline void PlayerSession::set_creationtime(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_creationtime(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.creationTime)
}

// optional int64 terminationTime = 8 [default = 0];
inline bool PlayerSession::_internal_has_terminationtime() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool PlayerSession::has_terminationtime() const {
  return _internal_has_terminationtime();
}
inline void PlayerSession::clear_terminationtime() {
  terminationtime_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PlayerSession::_internal_terminationtime() const {
  return terminationtime_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PlayerSession::terminationtime() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.terminationTime)
  return _internal_terminationtime();
}
inline void PlayerSession::_internal_set_terminationtime(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000200u;
  terminationtime_ = value;
}
inline void PlayerSession::set_terminationtime(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_terminationtime(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.terminationTime)
}

// optional int32 port = 9 [default = 0];
inline bool PlayerSession::_internal_has_port() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool PlayerSession::has_port() const {
  return _internal_has_port();
}
inline void PlayerSession::clear_port() {
  port_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerSession::_internal_port() const {
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerSession::port() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.port)
  return _internal_port();
}
inline void PlayerSession::_internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000400u;
  port_ = value;
}
inline void PlayerSession::set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.port)
}

// optional string playerData = 10;
inline bool PlayerSession::_internal_has_playerdata() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool PlayerSession::has_playerdata() const {
  return _internal_has_playerdata();
}
inline void PlayerSession::clear_playerdata() {
  playerdata_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& PlayerSession::playerdata() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.playerData)
  return _internal_playerdata();
}
inline void PlayerSession::set_playerdata(const std::string& value) {
  _internal_set_playerdata(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.playerData)
}
inline std::string* PlayerSession::mutable_playerdata() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.playerData)
  return _internal_mutable_playerdata();
}
inline const std::string& PlayerSession::_internal_playerdata() const {
  return playerdata_.Get();
}
inline void PlayerSession::_internal_set_playerdata(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  playerdata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PlayerSession::set_playerdata(std::string&& value) {
  _has_bits_[0] |= 0x00000040u;
  playerdata_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.playerData)
}
inline void PlayerSession::set_playerdata(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000040u;
  playerdata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.playerData)
}
inline void PlayerSession::set_playerdata(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000040u;
  playerdata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.playerData)
}
inline std::string* PlayerSession::_internal_mutable_playerdata() {
  _has_bits_[0] |= 0x00000040u;
  return playerdata_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PlayerSession::release_playerdata() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.playerData)
  if (!_internal_has_playerdata()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return playerdata_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PlayerSession::set_allocated_playerdata(std::string* playerdata) {
  if (playerdata != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  playerdata_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), playerdata,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.playerData)
}

// optional string dnsName = 11;
inline bool PlayerSession::_internal_has_dnsname() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool PlayerSession::has_dnsname() const {
  return _internal_has_dnsname();
}
inline void PlayerSession::clear_dnsname() {
  dnsname_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& PlayerSession::dnsname() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.dnsName)
  return _internal_dnsname();
}
inline void PlayerSession::set_dnsname(const std::string& value) {
  _internal_set_dnsname(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.dnsName)
}
inline std::string* PlayerSession::mutable_dnsname() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.dnsName)
  return _internal_mutable_dnsname();
}
inline const std::string& PlayerSession::_internal_dnsname() const {
  return dnsname_.Get();
}
inline void PlayerSession::_internal_set_dnsname(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  dnsname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PlayerSession::set_dnsname(std::string&& value) {
  _has_bits_[0] |= 0x00000080u;
  dnsname_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.dnsName)
}
inline void PlayerSession::set_dnsname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000080u;
  dnsname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.dnsName)
}
inline void PlayerSession::set_dnsname(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000080u;
  dnsname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.dnsName)
}
inline std::string* PlayerSession::_internal_mutable_dnsname() {
  _has_bits_[0] |= 0x00000080u;
  return dnsname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PlayerSession::release_dnsname() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.dnsName)
  if (!_internal_has_dnsname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  return dnsname_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PlayerSession::set_allocated_dnsname(std::string* dnsname) {
  if (dnsname != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  dnsname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), dnsname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.PlayerSession.dnsName)
}

// -------------------------------------------------------------------

// UpdateGameSession

// optional .com.amazon.whitewater.auxproxy.pbuffer.GameSession gameSession = 1;
inline bool UpdateGameSession::_internal_has_gamesession() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || gamesession_ != nullptr);
  return value;
}
inline bool UpdateGameSession::has_gamesession() const {
  return _internal_has_gamesession();
}
inline void UpdateGameSession::clear_gamesession() {
  if (gamesession_ != nullptr) gamesession_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::com::amazon::whitewater::auxproxy::pbuffer::GameSession& UpdateGameSession::_internal_gamesession() const {
  const ::com::amazon::whitewater::auxproxy::pbuffer::GameSession* p = gamesession_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::amazon::whitewater::auxproxy::pbuffer::GameSession&>(
      ::com::amazon::whitewater::auxproxy::pbuffer::_GameSession_default_instance_);
}
inline const ::com::amazon::whitewater::auxproxy::pbuffer::GameSession& UpdateGameSession::gamesession() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.UpdateGameSession.gameSession)
  return _internal_gamesession();
}
inline void UpdateGameSession::unsafe_arena_set_allocated_gamesession(
    ::com::amazon::whitewater::auxproxy::pbuffer::GameSession* gamesession) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gamesession_);
  }
  gamesession_ = gamesession;
  if (gamesession) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.UpdateGameSession.gameSession)
}
inline ::com::amazon::whitewater::auxproxy::pbuffer::GameSession* UpdateGameSession::release_gamesession() {
  _has_bits_[0] &= ~0x00000004u;
  ::com::amazon::whitewater::auxproxy::pbuffer::GameSession* temp = gamesession_;
  gamesession_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::com::amazon::whitewater::auxproxy::pbuffer::GameSession* UpdateGameSession::unsafe_arena_release_gamesession() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.UpdateGameSession.gameSession)
  _has_bits_[0] &= ~0x00000004u;
  ::com::amazon::whitewater::auxproxy::pbuffer::GameSession* temp = gamesession_;
  gamesession_ = nullptr;
  return temp;
}
inline ::com::amazon::whitewater::auxproxy::pbuffer::GameSession* UpdateGameSession::_internal_mutable_gamesession() {
  _has_bits_[0] |= 0x00000004u;
  if (gamesession_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::amazon::whitewater::auxproxy::pbuffer::GameSession>(GetArena());
    gamesession_ = p;
  }
  return gamesession_;
}
inline ::com::amazon::whitewater::auxproxy::pbuffer::GameSession* UpdateGameSession::mutable_gamesession() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.UpdateGameSession.gameSession)
  return _internal_mutable_gamesession();
}
inline void UpdateGameSession::set_allocated_gamesession(::com::amazon::whitewater::auxproxy::pbuffer::GameSession* gamesession) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete gamesession_;
  }
  if (gamesession) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(gamesession);
    if (message_arena != submessage_arena) {
      gamesession = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gamesession, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  gamesession_ = gamesession;
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.UpdateGameSession.gameSession)
}

// optional string updateReason = 2;
inline bool UpdateGameSession::_internal_has_updatereason() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UpdateGameSession::has_updatereason() const {
  return _internal_has_updatereason();
}
inline void UpdateGameSession::clear_updatereason() {
  updatereason_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UpdateGameSession::updatereason() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.UpdateGameSession.updateReason)
  return _internal_updatereason();
}
inline void UpdateGameSession::set_updatereason(const std::string& value) {
  _internal_set_updatereason(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.UpdateGameSession.updateReason)
}
inline std::string* UpdateGameSession::mutable_updatereason() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.UpdateGameSession.updateReason)
  return _internal_mutable_updatereason();
}
inline const std::string& UpdateGameSession::_internal_updatereason() const {
  return updatereason_.Get();
}
inline void UpdateGameSession::_internal_set_updatereason(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  updatereason_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void UpdateGameSession::set_updatereason(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  updatereason_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.UpdateGameSession.updateReason)
}
inline void UpdateGameSession::set_updatereason(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  updatereason_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.UpdateGameSession.updateReason)
}
inline void UpdateGameSession::set_updatereason(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  updatereason_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.UpdateGameSession.updateReason)
}
inline std::string* UpdateGameSession::_internal_mutable_updatereason() {
  _has_bits_[0] |= 0x00000001u;
  return updatereason_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* UpdateGameSession::release_updatereason() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.UpdateGameSession.updateReason)
  if (!_internal_has_updatereason()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return updatereason_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UpdateGameSession::set_allocated_updatereason(std::string* updatereason) {
  if (updatereason != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  updatereason_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), updatereason,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.UpdateGameSession.updateReason)
}

// optional string backfillTicketId = 3;
inline bool UpdateGameSession::_internal_has_backfillticketid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UpdateGameSession::has_backfillticketid() const {
  return _internal_has_backfillticketid();
}
inline void UpdateGameSession::clear_backfillticketid() {
  backfillticketid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UpdateGameSession::backfillticketid() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.UpdateGameSession.backfillTicketId)
  return _internal_backfillticketid();
}
inline void UpdateGameSession::set_backfillticketid(const std::string& value) {
  _internal_set_backfillticketid(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.UpdateGameSession.backfillTicketId)
}
inline std::string* UpdateGameSession::mutable_backfillticketid() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.UpdateGameSession.backfillTicketId)
  return _internal_mutable_backfillticketid();
}
inline const std::string& UpdateGameSession::_internal_backfillticketid() const {
  return backfillticketid_.Get();
}
inline void UpdateGameSession::_internal_set_backfillticketid(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  backfillticketid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void UpdateGameSession::set_backfillticketid(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  backfillticketid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.UpdateGameSession.backfillTicketId)
}
inline void UpdateGameSession::set_backfillticketid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  backfillticketid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.UpdateGameSession.backfillTicketId)
}
inline void UpdateGameSession::set_backfillticketid(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  backfillticketid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.UpdateGameSession.backfillTicketId)
}
inline std::string* UpdateGameSession::_internal_mutable_backfillticketid() {
  _has_bits_[0] |= 0x00000002u;
  return backfillticketid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* UpdateGameSession::release_backfillticketid() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.UpdateGameSession.backfillTicketId)
  if (!_internal_has_backfillticketid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return backfillticketid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UpdateGameSession::set_allocated_backfillticketid(std::string* backfillticketid) {
  if (backfillticketid != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  backfillticketid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), backfillticketid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.UpdateGameSession.backfillTicketId)
}

// -------------------------------------------------------------------

// TerminateProcess

// optional int64 terminationTime = 1 [default = 0];
inline bool TerminateProcess::_internal_has_terminationtime() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TerminateProcess::has_terminationtime() const {
  return _internal_has_terminationtime();
}
inline void TerminateProcess::clear_terminationtime() {
  terminationtime_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TerminateProcess::_internal_terminationtime() const {
  return terminationtime_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TerminateProcess::terminationtime() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.TerminateProcess.terminationTime)
  return _internal_terminationtime();
}
inline void TerminateProcess::_internal_set_terminationtime(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  terminationtime_ = value;
}
inline void TerminateProcess::set_terminationtime(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_terminationtime(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.TerminateProcess.terminationTime)
}

// -------------------------------------------------------------------

// ActivateGameSession

// optional .com.amazon.whitewater.auxproxy.pbuffer.GameSession gameSession = 1;
inline bool ActivateGameSession::_internal_has_gamesession() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || gamesession_ != nullptr);
  return value;
}
inline bool ActivateGameSession::has_gamesession() const {
  return _internal_has_gamesession();
}
inline void ActivateGameSession::clear_gamesession() {
  if (gamesession_ != nullptr) gamesession_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::com::amazon::whitewater::auxproxy::pbuffer::GameSession& ActivateGameSession::_internal_gamesession() const {
  const ::com::amazon::whitewater::auxproxy::pbuffer::GameSession* p = gamesession_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::amazon::whitewater::auxproxy::pbuffer::GameSession&>(
      ::com::amazon::whitewater::auxproxy::pbuffer::_GameSession_default_instance_);
}
inline const ::com::amazon::whitewater::auxproxy::pbuffer::GameSession& ActivateGameSession::gamesession() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.ActivateGameSession.gameSession)
  return _internal_gamesession();
}
inline void ActivateGameSession::unsafe_arena_set_allocated_gamesession(
    ::com::amazon::whitewater::auxproxy::pbuffer::GameSession* gamesession) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gamesession_);
  }
  gamesession_ = gamesession;
  if (gamesession) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.ActivateGameSession.gameSession)
}
inline ::com::amazon::whitewater::auxproxy::pbuffer::GameSession* ActivateGameSession::release_gamesession() {
  _has_bits_[0] &= ~0x00000001u;
  ::com::amazon::whitewater::auxproxy::pbuffer::GameSession* temp = gamesession_;
  gamesession_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::com::amazon::whitewater::auxproxy::pbuffer::GameSession* ActivateGameSession::unsafe_arena_release_gamesession() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.ActivateGameSession.gameSession)
  _has_bits_[0] &= ~0x00000001u;
  ::com::amazon::whitewater::auxproxy::pbuffer::GameSession* temp = gamesession_;
  gamesession_ = nullptr;
  return temp;
}
inline ::com::amazon::whitewater::auxproxy::pbuffer::GameSession* ActivateGameSession::_internal_mutable_gamesession() {
  _has_bits_[0] |= 0x00000001u;
  if (gamesession_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::amazon::whitewater::auxproxy::pbuffer::GameSession>(GetArena());
    gamesession_ = p;
  }
  return gamesession_;
}
inline ::com::amazon::whitewater::auxproxy::pbuffer::GameSession* ActivateGameSession::mutable_gamesession() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.ActivateGameSession.gameSession)
  return _internal_mutable_gamesession();
}
inline void ActivateGameSession::set_allocated_gamesession(::com::amazon::whitewater::auxproxy::pbuffer::GameSession* gamesession) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete gamesession_;
  }
  if (gamesession) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(gamesession);
    if (message_arena != submessage_arena) {
      gamesession = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gamesession, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  gamesession_ = gamesession;
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.ActivateGameSession.gameSession)
}

// -------------------------------------------------------------------

// ProcessReady

// repeated string logPathsToUpload = 1;
inline int ProcessReady::_internal_logpathstoupload_size() const {
  return logpathstoupload_.size();
}
inline int ProcessReady::logpathstoupload_size() const {
  return _internal_logpathstoupload_size();
}
inline void ProcessReady::clear_logpathstoupload() {
  logpathstoupload_.Clear();
}
inline std::string* ProcessReady::add_logpathstoupload() {
  // @@protoc_insertion_point(field_add_mutable:com.amazon.whitewater.auxproxy.pbuffer.ProcessReady.logPathsToUpload)
  return _internal_add_logpathstoupload();
}
inline const std::string& ProcessReady::_internal_logpathstoupload(int index) const {
  return logpathstoupload_.Get(index);
}
inline const std::string& ProcessReady::logpathstoupload(int index) const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.ProcessReady.logPathsToUpload)
  return _internal_logpathstoupload(index);
}
inline std::string* ProcessReady::mutable_logpathstoupload(int index) {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.ProcessReady.logPathsToUpload)
  return logpathstoupload_.Mutable(index);
}
inline void ProcessReady::set_logpathstoupload(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.ProcessReady.logPathsToUpload)
  logpathstoupload_.Mutable(index)->assign(value);
}
inline void ProcessReady::set_logpathstoupload(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.ProcessReady.logPathsToUpload)
  logpathstoupload_.Mutable(index)->assign(std::move(value));
}
inline void ProcessReady::set_logpathstoupload(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  logpathstoupload_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.ProcessReady.logPathsToUpload)
}
inline void ProcessReady::set_logpathstoupload(int index, const char* value, size_t size) {
  logpathstoupload_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.ProcessReady.logPathsToUpload)
}
inline std::string* ProcessReady::_internal_add_logpathstoupload() {
  return logpathstoupload_.Add();
}
inline void ProcessReady::add_logpathstoupload(const std::string& value) {
  logpathstoupload_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:com.amazon.whitewater.auxproxy.pbuffer.ProcessReady.logPathsToUpload)
}
inline void ProcessReady::add_logpathstoupload(std::string&& value) {
  logpathstoupload_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:com.amazon.whitewater.auxproxy.pbuffer.ProcessReady.logPathsToUpload)
}
inline void ProcessReady::add_logpathstoupload(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  logpathstoupload_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:com.amazon.whitewater.auxproxy.pbuffer.ProcessReady.logPathsToUpload)
}
inline void ProcessReady::add_logpathstoupload(const char* value, size_t size) {
  logpathstoupload_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:com.amazon.whitewater.auxproxy.pbuffer.ProcessReady.logPathsToUpload)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ProcessReady::logpathstoupload() const {
  // @@protoc_insertion_point(field_list:com.amazon.whitewater.auxproxy.pbuffer.ProcessReady.logPathsToUpload)
  return logpathstoupload_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ProcessReady::mutable_logpathstoupload() {
  // @@protoc_insertion_point(field_mutable_list:com.amazon.whitewater.auxproxy.pbuffer.ProcessReady.logPathsToUpload)
  return &logpathstoupload_;
}

// optional int32 port = 2 [default = 0];
inline bool ProcessReady::_internal_has_port() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ProcessReady::has_port() const {
  return _internal_has_port();
}
inline void ProcessReady::clear_port() {
  port_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ProcessReady::_internal_port() const {
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ProcessReady::port() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.ProcessReady.port)
  return _internal_port();
}
inline void ProcessReady::_internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  port_ = value;
}
inline void ProcessReady::set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.ProcessReady.port)
}

// -------------------------------------------------------------------

// ProcessEnding

// -------------------------------------------------------------------

// ReportHealth

// required bool healthStatus = 1;
inline bool ReportHealth::_internal_has_healthstatus() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReportHealth::has_healthstatus() const {
  return _internal_has_healthstatus();
}
inline void ReportHealth::clear_healthstatus() {
  healthstatus_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool ReportHealth::_internal_healthstatus() const {
  return healthstatus_;
}
inline bool ReportHealth::healthstatus() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.ReportHealth.healthStatus)
  return _internal_healthstatus();
}
inline void ReportHealth::_internal_set_healthstatus(bool value) {
  _has_bits_[0] |= 0x00000001u;
  healthstatus_ = value;
}
inline void ReportHealth::set_healthstatus(bool value) {
  _internal_set_healthstatus(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.ReportHealth.healthStatus)
}

// -------------------------------------------------------------------

// GameSessionActivate

// optional string gameSessionId = 1;
inline bool GameSessionActivate::_internal_has_gamesessionid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GameSessionActivate::has_gamesessionid() const {
  return _internal_has_gamesessionid();
}
inline void GameSessionActivate::clear_gamesessionid() {
  gamesessionid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GameSessionActivate::gamesessionid() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.GameSessionActivate.gameSessionId)
  return _internal_gamesessionid();
}
inline void GameSessionActivate::set_gamesessionid(const std::string& value) {
  _internal_set_gamesessionid(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.GameSessionActivate.gameSessionId)
}
inline std::string* GameSessionActivate::mutable_gamesessionid() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.GameSessionActivate.gameSessionId)
  return _internal_mutable_gamesessionid();
}
inline const std::string& GameSessionActivate::_internal_gamesessionid() const {
  return gamesessionid_.Get();
}
inline void GameSessionActivate::_internal_set_gamesessionid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  gamesessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void GameSessionActivate::set_gamesessionid(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  gamesessionid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.GameSessionActivate.gameSessionId)
}
inline void GameSessionActivate::set_gamesessionid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  gamesessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.GameSessionActivate.gameSessionId)
}
inline void GameSessionActivate::set_gamesessionid(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  gamesessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.GameSessionActivate.gameSessionId)
}
inline std::string* GameSessionActivate::_internal_mutable_gamesessionid() {
  _has_bits_[0] |= 0x00000001u;
  return gamesessionid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* GameSessionActivate::release_gamesessionid() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.GameSessionActivate.gameSessionId)
  if (!_internal_has_gamesessionid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return gamesessionid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GameSessionActivate::set_allocated_gamesessionid(std::string* gamesessionid) {
  if (gamesessionid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  gamesessionid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gamesessionid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.GameSessionActivate.gameSessionId)
}

// optional int32 maxPlayers = 2 [default = 0];
inline bool GameSessionActivate::_internal_has_maxplayers() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GameSessionActivate::has_maxplayers() const {
  return _internal_has_maxplayers();
}
inline void GameSessionActivate::clear_maxplayers() {
  maxplayers_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameSessionActivate::_internal_maxplayers() const {
  return maxplayers_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameSessionActivate::maxplayers() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.GameSessionActivate.maxPlayers)
  return _internal_maxplayers();
}
inline void GameSessionActivate::_internal_set_maxplayers(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  maxplayers_ = value;
}
inline void GameSessionActivate::set_maxplayers(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_maxplayers(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.GameSessionActivate.maxPlayers)
}

// -------------------------------------------------------------------

// GameSessionTerminate

// optional string gameSessionId = 1;
inline bool GameSessionTerminate::_internal_has_gamesessionid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GameSessionTerminate::has_gamesessionid() const {
  return _internal_has_gamesessionid();
}
inline void GameSessionTerminate::clear_gamesessionid() {
  gamesessionid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GameSessionTerminate::gamesessionid() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.GameSessionTerminate.gameSessionId)
  return _internal_gamesessionid();
}
inline void GameSessionTerminate::set_gamesessionid(const std::string& value) {
  _internal_set_gamesessionid(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.GameSessionTerminate.gameSessionId)
}
inline std::string* GameSessionTerminate::mutable_gamesessionid() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.GameSessionTerminate.gameSessionId)
  return _internal_mutable_gamesessionid();
}
inline const std::string& GameSessionTerminate::_internal_gamesessionid() const {
  return gamesessionid_.Get();
}
inline void GameSessionTerminate::_internal_set_gamesessionid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  gamesessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void GameSessionTerminate::set_gamesessionid(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  gamesessionid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.GameSessionTerminate.gameSessionId)
}
inline void GameSessionTerminate::set_gamesessionid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  gamesessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.GameSessionTerminate.gameSessionId)
}
inline void GameSessionTerminate::set_gamesessionid(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  gamesessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.GameSessionTerminate.gameSessionId)
}
inline std::string* GameSessionTerminate::_internal_mutable_gamesessionid() {
  _has_bits_[0] |= 0x00000001u;
  return gamesessionid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* GameSessionTerminate::release_gamesessionid() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.GameSessionTerminate.gameSessionId)
  if (!_internal_has_gamesessionid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return gamesessionid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GameSessionTerminate::set_allocated_gamesessionid(std::string* gamesessionid) {
  if (gamesessionid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  gamesessionid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gamesessionid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.GameSessionTerminate.gameSessionId)
}

// -------------------------------------------------------------------

// UpdatePlayerSessionCreationPolicy

// optional string gameSessionId = 1;
inline bool UpdatePlayerSessionCreationPolicy::_internal_has_gamesessionid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UpdatePlayerSessionCreationPolicy::has_gamesessionid() const {
  return _internal_has_gamesessionid();
}
inline void UpdatePlayerSessionCreationPolicy::clear_gamesessionid() {
  gamesessionid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UpdatePlayerSessionCreationPolicy::gamesessionid() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.UpdatePlayerSessionCreationPolicy.gameSessionId)
  return _internal_gamesessionid();
}
inline void UpdatePlayerSessionCreationPolicy::set_gamesessionid(const std::string& value) {
  _internal_set_gamesessionid(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.UpdatePlayerSessionCreationPolicy.gameSessionId)
}
inline std::string* UpdatePlayerSessionCreationPolicy::mutable_gamesessionid() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.UpdatePlayerSessionCreationPolicy.gameSessionId)
  return _internal_mutable_gamesessionid();
}
inline const std::string& UpdatePlayerSessionCreationPolicy::_internal_gamesessionid() const {
  return gamesessionid_.Get();
}
inline void UpdatePlayerSessionCreationPolicy::_internal_set_gamesessionid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  gamesessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void UpdatePlayerSessionCreationPolicy::set_gamesessionid(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  gamesessionid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.UpdatePlayerSessionCreationPolicy.gameSessionId)
}
inline void UpdatePlayerSessionCreationPolicy::set_gamesessionid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  gamesessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.UpdatePlayerSessionCreationPolicy.gameSessionId)
}
inline void UpdatePlayerSessionCreationPolicy::set_gamesessionid(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  gamesessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.UpdatePlayerSessionCreationPolicy.gameSessionId)
}
inline std::string* UpdatePlayerSessionCreationPolicy::_internal_mutable_gamesessionid() {
  _has_bits_[0] |= 0x00000001u;
  return gamesessionid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* UpdatePlayerSessionCreationPolicy::release_gamesessionid() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.UpdatePlayerSessionCreationPolicy.gameSessionId)
  if (!_internal_has_gamesessionid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return gamesessionid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UpdatePlayerSessionCreationPolicy::set_allocated_gamesessionid(std::string* gamesessionid) {
  if (gamesessionid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  gamesessionid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gamesessionid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.UpdatePlayerSessionCreationPolicy.gameSessionId)
}

// optional string newPlayerSessionCreationPolicy = 2;
inline bool UpdatePlayerSessionCreationPolicy::_internal_has_newplayersessioncreationpolicy() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UpdatePlayerSessionCreationPolicy::has_newplayersessioncreationpolicy() const {
  return _internal_has_newplayersessioncreationpolicy();
}
inline void UpdatePlayerSessionCreationPolicy::clear_newplayersessioncreationpolicy() {
  newplayersessioncreationpolicy_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UpdatePlayerSessionCreationPolicy::newplayersessioncreationpolicy() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.UpdatePlayerSessionCreationPolicy.newPlayerSessionCreationPolicy)
  return _internal_newplayersessioncreationpolicy();
}
inline void UpdatePlayerSessionCreationPolicy::set_newplayersessioncreationpolicy(const std::string& value) {
  _internal_set_newplayersessioncreationpolicy(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.UpdatePlayerSessionCreationPolicy.newPlayerSessionCreationPolicy)
}
inline std::string* UpdatePlayerSessionCreationPolicy::mutable_newplayersessioncreationpolicy() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.UpdatePlayerSessionCreationPolicy.newPlayerSessionCreationPolicy)
  return _internal_mutable_newplayersessioncreationpolicy();
}
inline const std::string& UpdatePlayerSessionCreationPolicy::_internal_newplayersessioncreationpolicy() const {
  return newplayersessioncreationpolicy_.Get();
}
inline void UpdatePlayerSessionCreationPolicy::_internal_set_newplayersessioncreationpolicy(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  newplayersessioncreationpolicy_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void UpdatePlayerSessionCreationPolicy::set_newplayersessioncreationpolicy(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  newplayersessioncreationpolicy_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.UpdatePlayerSessionCreationPolicy.newPlayerSessionCreationPolicy)
}
inline void UpdatePlayerSessionCreationPolicy::set_newplayersessioncreationpolicy(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  newplayersessioncreationpolicy_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.UpdatePlayerSessionCreationPolicy.newPlayerSessionCreationPolicy)
}
inline void UpdatePlayerSessionCreationPolicy::set_newplayersessioncreationpolicy(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  newplayersessioncreationpolicy_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.UpdatePlayerSessionCreationPolicy.newPlayerSessionCreationPolicy)
}
inline std::string* UpdatePlayerSessionCreationPolicy::_internal_mutable_newplayersessioncreationpolicy() {
  _has_bits_[0] |= 0x00000002u;
  return newplayersessioncreationpolicy_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* UpdatePlayerSessionCreationPolicy::release_newplayersessioncreationpolicy() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.UpdatePlayerSessionCreationPolicy.newPlayerSessionCreationPolicy)
  if (!_internal_has_newplayersessioncreationpolicy()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return newplayersessioncreationpolicy_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UpdatePlayerSessionCreationPolicy::set_allocated_newplayersessioncreationpolicy(std::string* newplayersessioncreationpolicy) {
  if (newplayersessioncreationpolicy != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  newplayersessioncreationpolicy_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), newplayersessioncreationpolicy,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.UpdatePlayerSessionCreationPolicy.newPlayerSessionCreationPolicy)
}

// -------------------------------------------------------------------

// AcceptPlayerSession

// optional string gameSessionId = 1;
inline bool AcceptPlayerSession::_internal_has_gamesessionid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AcceptPlayerSession::has_gamesessionid() const {
  return _internal_has_gamesessionid();
}
inline void AcceptPlayerSession::clear_gamesessionid() {
  gamesessionid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AcceptPlayerSession::gamesessionid() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.AcceptPlayerSession.gameSessionId)
  return _internal_gamesessionid();
}
inline void AcceptPlayerSession::set_gamesessionid(const std::string& value) {
  _internal_set_gamesessionid(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.AcceptPlayerSession.gameSessionId)
}
inline std::string* AcceptPlayerSession::mutable_gamesessionid() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.AcceptPlayerSession.gameSessionId)
  return _internal_mutable_gamesessionid();
}
inline const std::string& AcceptPlayerSession::_internal_gamesessionid() const {
  return gamesessionid_.Get();
}
inline void AcceptPlayerSession::_internal_set_gamesessionid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  gamesessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void AcceptPlayerSession::set_gamesessionid(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  gamesessionid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.AcceptPlayerSession.gameSessionId)
}
inline void AcceptPlayerSession::set_gamesessionid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  gamesessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.AcceptPlayerSession.gameSessionId)
}
inline void AcceptPlayerSession::set_gamesessionid(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  gamesessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.AcceptPlayerSession.gameSessionId)
}
inline std::string* AcceptPlayerSession::_internal_mutable_gamesessionid() {
  _has_bits_[0] |= 0x00000001u;
  return gamesessionid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* AcceptPlayerSession::release_gamesessionid() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.AcceptPlayerSession.gameSessionId)
  if (!_internal_has_gamesessionid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return gamesessionid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AcceptPlayerSession::set_allocated_gamesessionid(std::string* gamesessionid) {
  if (gamesessionid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  gamesessionid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gamesessionid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.AcceptPlayerSession.gameSessionId)
}

// optional string playerSessionId = 2;
inline bool AcceptPlayerSession::_internal_has_playersessionid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AcceptPlayerSession::has_playersessionid() const {
  return _internal_has_playersessionid();
}
inline void AcceptPlayerSession::clear_playersessionid() {
  playersessionid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AcceptPlayerSession::playersessionid() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.AcceptPlayerSession.playerSessionId)
  return _internal_playersessionid();
}
inline void AcceptPlayerSession::set_playersessionid(const std::string& value) {
  _internal_set_playersessionid(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.AcceptPlayerSession.playerSessionId)
}
inline std::string* AcceptPlayerSession::mutable_playersessionid() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.AcceptPlayerSession.playerSessionId)
  return _internal_mutable_playersessionid();
}
inline const std::string& AcceptPlayerSession::_internal_playersessionid() const {
  return playersessionid_.Get();
}
inline void AcceptPlayerSession::_internal_set_playersessionid(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  playersessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void AcceptPlayerSession::set_playersessionid(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  playersessionid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.AcceptPlayerSession.playerSessionId)
}
inline void AcceptPlayerSession::set_playersessionid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  playersessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.AcceptPlayerSession.playerSessionId)
}
inline void AcceptPlayerSession::set_playersessionid(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  playersessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.AcceptPlayerSession.playerSessionId)
}
inline std::string* AcceptPlayerSession::_internal_mutable_playersessionid() {
  _has_bits_[0] |= 0x00000002u;
  return playersessionid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* AcceptPlayerSession::release_playersessionid() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.AcceptPlayerSession.playerSessionId)
  if (!_internal_has_playersessionid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return playersessionid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AcceptPlayerSession::set_allocated_playersessionid(std::string* playersessionid) {
  if (playersessionid != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  playersessionid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), playersessionid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.AcceptPlayerSession.playerSessionId)
}

// -------------------------------------------------------------------

// RemovePlayerSession

// optional string gameSessionId = 1;
inline bool RemovePlayerSession::_internal_has_gamesessionid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RemovePlayerSession::has_gamesessionid() const {
  return _internal_has_gamesessionid();
}
inline void RemovePlayerSession::clear_gamesessionid() {
  gamesessionid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RemovePlayerSession::gamesessionid() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.RemovePlayerSession.gameSessionId)
  return _internal_gamesessionid();
}
inline void RemovePlayerSession::set_gamesessionid(const std::string& value) {
  _internal_set_gamesessionid(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.RemovePlayerSession.gameSessionId)
}
inline std::string* RemovePlayerSession::mutable_gamesessionid() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.RemovePlayerSession.gameSessionId)
  return _internal_mutable_gamesessionid();
}
inline const std::string& RemovePlayerSession::_internal_gamesessionid() const {
  return gamesessionid_.Get();
}
inline void RemovePlayerSession::_internal_set_gamesessionid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  gamesessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void RemovePlayerSession::set_gamesessionid(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  gamesessionid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.RemovePlayerSession.gameSessionId)
}
inline void RemovePlayerSession::set_gamesessionid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  gamesessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.RemovePlayerSession.gameSessionId)
}
inline void RemovePlayerSession::set_gamesessionid(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  gamesessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.RemovePlayerSession.gameSessionId)
}
inline std::string* RemovePlayerSession::_internal_mutable_gamesessionid() {
  _has_bits_[0] |= 0x00000001u;
  return gamesessionid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* RemovePlayerSession::release_gamesessionid() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.RemovePlayerSession.gameSessionId)
  if (!_internal_has_gamesessionid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return gamesessionid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RemovePlayerSession::set_allocated_gamesessionid(std::string* gamesessionid) {
  if (gamesessionid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  gamesessionid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gamesessionid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.RemovePlayerSession.gameSessionId)
}

// optional string playerSessionId = 2;
inline bool RemovePlayerSession::_internal_has_playersessionid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RemovePlayerSession::has_playersessionid() const {
  return _internal_has_playersessionid();
}
inline void RemovePlayerSession::clear_playersessionid() {
  playersessionid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RemovePlayerSession::playersessionid() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.RemovePlayerSession.playerSessionId)
  return _internal_playersessionid();
}
inline void RemovePlayerSession::set_playersessionid(const std::string& value) {
  _internal_set_playersessionid(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.RemovePlayerSession.playerSessionId)
}
inline std::string* RemovePlayerSession::mutable_playersessionid() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.RemovePlayerSession.playerSessionId)
  return _internal_mutable_playersessionid();
}
inline const std::string& RemovePlayerSession::_internal_playersessionid() const {
  return playersessionid_.Get();
}
inline void RemovePlayerSession::_internal_set_playersessionid(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  playersessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void RemovePlayerSession::set_playersessionid(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  playersessionid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.RemovePlayerSession.playerSessionId)
}
inline void RemovePlayerSession::set_playersessionid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  playersessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.RemovePlayerSession.playerSessionId)
}
inline void RemovePlayerSession::set_playersessionid(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  playersessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.RemovePlayerSession.playerSessionId)
}
inline std::string* RemovePlayerSession::_internal_mutable_playersessionid() {
  _has_bits_[0] |= 0x00000002u;
  return playersessionid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* RemovePlayerSession::release_playersessionid() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.RemovePlayerSession.playerSessionId)
  if (!_internal_has_playersessionid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return playersessionid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void RemovePlayerSession::set_allocated_playersessionid(std::string* playersessionid) {
  if (playersessionid != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  playersessionid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), playersessionid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.RemovePlayerSession.playerSessionId)
}

// -------------------------------------------------------------------

// DescribePlayerSessionsRequest

// optional string gameSessionId = 1;
inline bool DescribePlayerSessionsRequest::_internal_has_gamesessionid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DescribePlayerSessionsRequest::has_gamesessionid() const {
  return _internal_has_gamesessionid();
}
inline void DescribePlayerSessionsRequest::clear_gamesessionid() {
  gamesessionid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DescribePlayerSessionsRequest::gamesessionid() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest.gameSessionId)
  return _internal_gamesessionid();
}
inline void DescribePlayerSessionsRequest::set_gamesessionid(const std::string& value) {
  _internal_set_gamesessionid(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest.gameSessionId)
}
inline std::string* DescribePlayerSessionsRequest::mutable_gamesessionid() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest.gameSessionId)
  return _internal_mutable_gamesessionid();
}
inline const std::string& DescribePlayerSessionsRequest::_internal_gamesessionid() const {
  return gamesessionid_.Get();
}
inline void DescribePlayerSessionsRequest::_internal_set_gamesessionid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  gamesessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void DescribePlayerSessionsRequest::set_gamesessionid(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  gamesessionid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest.gameSessionId)
}
inline void DescribePlayerSessionsRequest::set_gamesessionid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  gamesessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest.gameSessionId)
}
inline void DescribePlayerSessionsRequest::set_gamesessionid(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  gamesessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest.gameSessionId)
}
inline std::string* DescribePlayerSessionsRequest::_internal_mutable_gamesessionid() {
  _has_bits_[0] |= 0x00000001u;
  return gamesessionid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* DescribePlayerSessionsRequest::release_gamesessionid() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest.gameSessionId)
  if (!_internal_has_gamesessionid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return gamesessionid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DescribePlayerSessionsRequest::set_allocated_gamesessionid(std::string* gamesessionid) {
  if (gamesessionid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  gamesessionid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gamesessionid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest.gameSessionId)
}

// optional string playerId = 2;
inline bool DescribePlayerSessionsRequest::_internal_has_playerid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DescribePlayerSessionsRequest::has_playerid() const {
  return _internal_has_playerid();
}
inline void DescribePlayerSessionsRequest::clear_playerid() {
  playerid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DescribePlayerSessionsRequest::playerid() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest.playerId)
  return _internal_playerid();
}
inline void DescribePlayerSessionsRequest::set_playerid(const std::string& value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest.playerId)
}
inline std::string* DescribePlayerSessionsRequest::mutable_playerid() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest.playerId)
  return _internal_mutable_playerid();
}
inline const std::string& DescribePlayerSessionsRequest::_internal_playerid() const {
  return playerid_.Get();
}
inline void DescribePlayerSessionsRequest::_internal_set_playerid(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  playerid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void DescribePlayerSessionsRequest::set_playerid(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  playerid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest.playerId)
}
inline void DescribePlayerSessionsRequest::set_playerid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  playerid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest.playerId)
}
inline void DescribePlayerSessionsRequest::set_playerid(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  playerid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest.playerId)
}
inline std::string* DescribePlayerSessionsRequest::_internal_mutable_playerid() {
  _has_bits_[0] |= 0x00000002u;
  return playerid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* DescribePlayerSessionsRequest::release_playerid() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest.playerId)
  if (!_internal_has_playerid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return playerid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DescribePlayerSessionsRequest::set_allocated_playerid(std::string* playerid) {
  if (playerid != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  playerid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), playerid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest.playerId)
}

// optional string playerSessionId = 3;
inline bool DescribePlayerSessionsRequest::_internal_has_playersessionid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DescribePlayerSessionsRequest::has_playersessionid() const {
  return _internal_has_playersessionid();
}
inline void DescribePlayerSessionsRequest::clear_playersessionid() {
  playersessionid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DescribePlayerSessionsRequest::playersessionid() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest.playerSessionId)
  return _internal_playersessionid();
}
inline void DescribePlayerSessionsRequest::set_playersessionid(const std::string& value) {
  _internal_set_playersessionid(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest.playerSessionId)
}
inline std::string* DescribePlayerSessionsRequest::mutable_playersessionid() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest.playerSessionId)
  return _internal_mutable_playersessionid();
}
inline const std::string& DescribePlayerSessionsRequest::_internal_playersessionid() const {
  return playersessionid_.Get();
}
inline void DescribePlayerSessionsRequest::_internal_set_playersessionid(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  playersessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void DescribePlayerSessionsRequest::set_playersessionid(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  playersessionid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest.playerSessionId)
}
inline void DescribePlayerSessionsRequest::set_playersessionid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  playersessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest.playerSessionId)
}
inline void DescribePlayerSessionsRequest::set_playersessionid(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  playersessionid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest.playerSessionId)
}
inline std::string* DescribePlayerSessionsRequest::_internal_mutable_playersessionid() {
  _has_bits_[0] |= 0x00000004u;
  return playersessionid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* DescribePlayerSessionsRequest::release_playersessionid() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest.playerSessionId)
  if (!_internal_has_playersessionid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return playersessionid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DescribePlayerSessionsRequest::set_allocated_playersessionid(std::string* playersessionid) {
  if (playersessionid != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  playersessionid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), playersessionid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest.playerSessionId)
}

// optional string playerSessionStatusFilter = 4;
inline bool DescribePlayerSessionsRequest::_internal_has_playersessionstatusfilter() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DescribePlayerSessionsRequest::has_playersessionstatusfilter() const {
  return _internal_has_playersessionstatusfilter();
}
inline void DescribePlayerSessionsRequest::clear_playersessionstatusfilter() {
  playersessionstatusfilter_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& DescribePlayerSessionsRequest::playersessionstatusfilter() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest.playerSessionStatusFilter)
  return _internal_playersessionstatusfilter();
}
inline void DescribePlayerSessionsRequest::set_playersessionstatusfilter(const std::string& value) {
  _internal_set_playersessionstatusfilter(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest.playerSessionStatusFilter)
}
inline std::string* DescribePlayerSessionsRequest::mutable_playersessionstatusfilter() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest.playerSessionStatusFilter)
  return _internal_mutable_playersessionstatusfilter();
}
inline const std::string& DescribePlayerSessionsRequest::_internal_playersessionstatusfilter() const {
  return playersessionstatusfilter_.Get();
}
inline void DescribePlayerSessionsRequest::_internal_set_playersessionstatusfilter(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  playersessionstatusfilter_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void DescribePlayerSessionsRequest::set_playersessionstatusfilter(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  playersessionstatusfilter_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest.playerSessionStatusFilter)
}
inline void DescribePlayerSessionsRequest::set_playersessionstatusfilter(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  playersessionstatusfilter_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest.playerSessionStatusFilter)
}
inline void DescribePlayerSessionsRequest::set_playersessionstatusfilter(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000008u;
  playersessionstatusfilter_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest.playerSessionStatusFilter)
}
inline std::string* DescribePlayerSessionsRequest::_internal_mutable_playersessionstatusfilter() {
  _has_bits_[0] |= 0x00000008u;
  return playersessionstatusfilter_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* DescribePlayerSessionsRequest::release_playersessionstatusfilter() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest.playerSessionStatusFilter)
  if (!_internal_has_playersessionstatusfilter()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return playersessionstatusfilter_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DescribePlayerSessionsRequest::set_allocated_playersessionstatusfilter(std::string* playersessionstatusfilter) {
  if (playersessionstatusfilter != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  playersessionstatusfilter_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), playersessionstatusfilter,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest.playerSessionStatusFilter)
}

// optional string nextToken = 5;
inline bool DescribePlayerSessionsRequest::_internal_has_nexttoken() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DescribePlayerSessionsRequest::has_nexttoken() const {
  return _internal_has_nexttoken();
}
inline void DescribePlayerSessionsRequest::clear_nexttoken() {
  nexttoken_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& DescribePlayerSessionsRequest::nexttoken() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest.nextToken)
  return _internal_nexttoken();
}
inline void DescribePlayerSessionsRequest::set_nexttoken(const std::string& value) {
  _internal_set_nexttoken(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest.nextToken)
}
inline std::string* DescribePlayerSessionsRequest::mutable_nexttoken() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest.nextToken)
  return _internal_mutable_nexttoken();
}
inline const std::string& DescribePlayerSessionsRequest::_internal_nexttoken() const {
  return nexttoken_.Get();
}
inline void DescribePlayerSessionsRequest::_internal_set_nexttoken(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  nexttoken_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void DescribePlayerSessionsRequest::set_nexttoken(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  nexttoken_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest.nextToken)
}
inline void DescribePlayerSessionsRequest::set_nexttoken(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  nexttoken_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest.nextToken)
}
inline void DescribePlayerSessionsRequest::set_nexttoken(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000010u;
  nexttoken_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest.nextToken)
}
inline std::string* DescribePlayerSessionsRequest::_internal_mutable_nexttoken() {
  _has_bits_[0] |= 0x00000010u;
  return nexttoken_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* DescribePlayerSessionsRequest::release_nexttoken() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest.nextToken)
  if (!_internal_has_nexttoken()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return nexttoken_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DescribePlayerSessionsRequest::set_allocated_nexttoken(std::string* nexttoken) {
  if (nexttoken != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  nexttoken_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nexttoken,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest.nextToken)
}

// optional int32 limit = 6 [default = 0];
inline bool DescribePlayerSessionsRequest::_internal_has_limit() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool DescribePlayerSessionsRequest::has_limit() const {
  return _internal_has_limit();
}
inline void DescribePlayerSessionsRequest::clear_limit() {
  limit_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DescribePlayerSessionsRequest::_internal_limit() const {
  return limit_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DescribePlayerSessionsRequest::limit() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest.limit)
  return _internal_limit();
}
inline void DescribePlayerSessionsRequest::_internal_set_limit(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  limit_ = value;
}
inline void DescribePlayerSessionsRequest::set_limit(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsRequest.limit)
}

// -------------------------------------------------------------------

// BackfillMatchmakingRequest

// optional string ticketId = 1;
inline bool BackfillMatchmakingRequest::_internal_has_ticketid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BackfillMatchmakingRequest::has_ticketid() const {
  return _internal_has_ticketid();
}
inline void BackfillMatchmakingRequest::clear_ticketid() {
  ticketid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BackfillMatchmakingRequest::ticketid() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.BackfillMatchmakingRequest.ticketId)
  return _internal_ticketid();
}
inline void BackfillMatchmakingRequest::set_ticketid(const std::string& value) {
  _internal_set_ticketid(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.BackfillMatchmakingRequest.ticketId)
}
inline std::string* BackfillMatchmakingRequest::mutable_ticketid() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.BackfillMatchmakingRequest.ticketId)
  return _internal_mutable_ticketid();
}
inline const std::string& BackfillMatchmakingRequest::_internal_ticketid() const {
  return ticketid_.Get();
}
inline void BackfillMatchmakingRequest::_internal_set_ticketid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ticketid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void BackfillMatchmakingRequest::set_ticketid(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  ticketid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.BackfillMatchmakingRequest.ticketId)
}
inline void BackfillMatchmakingRequest::set_ticketid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  ticketid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.BackfillMatchmakingRequest.ticketId)
}
inline void BackfillMatchmakingRequest::set_ticketid(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  ticketid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.BackfillMatchmakingRequest.ticketId)
}
inline std::string* BackfillMatchmakingRequest::_internal_mutable_ticketid() {
  _has_bits_[0] |= 0x00000001u;
  return ticketid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* BackfillMatchmakingRequest::release_ticketid() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.BackfillMatchmakingRequest.ticketId)
  if (!_internal_has_ticketid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return ticketid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BackfillMatchmakingRequest::set_allocated_ticketid(std::string* ticketid) {
  if (ticketid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ticketid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ticketid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.BackfillMatchmakingRequest.ticketId)
}

// optional string gameSessionArn = 2;
inline bool BackfillMatchmakingRequest::_internal_has_gamesessionarn() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BackfillMatchmakingRequest::has_gamesessionarn() const {
  return _internal_has_gamesessionarn();
}
inline void BackfillMatchmakingRequest::clear_gamesessionarn() {
  gamesessionarn_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BackfillMatchmakingRequest::gamesessionarn() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.BackfillMatchmakingRequest.gameSessionArn)
  return _internal_gamesessionarn();
}
inline void BackfillMatchmakingRequest::set_gamesessionarn(const std::string& value) {
  _internal_set_gamesessionarn(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.BackfillMatchmakingRequest.gameSessionArn)
}
inline std::string* BackfillMatchmakingRequest::mutable_gamesessionarn() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.BackfillMatchmakingRequest.gameSessionArn)
  return _internal_mutable_gamesessionarn();
}
inline const std::string& BackfillMatchmakingRequest::_internal_gamesessionarn() const {
  return gamesessionarn_.Get();
}
inline void BackfillMatchmakingRequest::_internal_set_gamesessionarn(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  gamesessionarn_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void BackfillMatchmakingRequest::set_gamesessionarn(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  gamesessionarn_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.BackfillMatchmakingRequest.gameSessionArn)
}
inline void BackfillMatchmakingRequest::set_gamesessionarn(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  gamesessionarn_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.BackfillMatchmakingRequest.gameSessionArn)
}
inline void BackfillMatchmakingRequest::set_gamesessionarn(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  gamesessionarn_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.BackfillMatchmakingRequest.gameSessionArn)
}
inline std::string* BackfillMatchmakingRequest::_internal_mutable_gamesessionarn() {
  _has_bits_[0] |= 0x00000002u;
  return gamesessionarn_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* BackfillMatchmakingRequest::release_gamesessionarn() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.BackfillMatchmakingRequest.gameSessionArn)
  if (!_internal_has_gamesessionarn()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return gamesessionarn_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BackfillMatchmakingRequest::set_allocated_gamesessionarn(std::string* gamesessionarn) {
  if (gamesessionarn != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  gamesessionarn_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gamesessionarn,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.BackfillMatchmakingRequest.gameSessionArn)
}

// optional string matchmakingConfigurationArn = 3;
inline bool BackfillMatchmakingRequest::_internal_has_matchmakingconfigurationarn() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BackfillMatchmakingRequest::has_matchmakingconfigurationarn() const {
  return _internal_has_matchmakingconfigurationarn();
}
inline void BackfillMatchmakingRequest::clear_matchmakingconfigurationarn() {
  matchmakingconfigurationarn_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& BackfillMatchmakingRequest::matchmakingconfigurationarn() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.BackfillMatchmakingRequest.matchmakingConfigurationArn)
  return _internal_matchmakingconfigurationarn();
}
inline void BackfillMatchmakingRequest::set_matchmakingconfigurationarn(const std::string& value) {
  _internal_set_matchmakingconfigurationarn(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.BackfillMatchmakingRequest.matchmakingConfigurationArn)
}
inline std::string* BackfillMatchmakingRequest::mutable_matchmakingconfigurationarn() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.BackfillMatchmakingRequest.matchmakingConfigurationArn)
  return _internal_mutable_matchmakingconfigurationarn();
}
inline const std::string& BackfillMatchmakingRequest::_internal_matchmakingconfigurationarn() const {
  return matchmakingconfigurationarn_.Get();
}
inline void BackfillMatchmakingRequest::_internal_set_matchmakingconfigurationarn(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  matchmakingconfigurationarn_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void BackfillMatchmakingRequest::set_matchmakingconfigurationarn(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  matchmakingconfigurationarn_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.BackfillMatchmakingRequest.matchmakingConfigurationArn)
}
inline void BackfillMatchmakingRequest::set_matchmakingconfigurationarn(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  matchmakingconfigurationarn_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.BackfillMatchmakingRequest.matchmakingConfigurationArn)
}
inline void BackfillMatchmakingRequest::set_matchmakingconfigurationarn(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  matchmakingconfigurationarn_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.BackfillMatchmakingRequest.matchmakingConfigurationArn)
}
inline std::string* BackfillMatchmakingRequest::_internal_mutable_matchmakingconfigurationarn() {
  _has_bits_[0] |= 0x00000004u;
  return matchmakingconfigurationarn_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* BackfillMatchmakingRequest::release_matchmakingconfigurationarn() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.BackfillMatchmakingRequest.matchmakingConfigurationArn)
  if (!_internal_has_matchmakingconfigurationarn()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return matchmakingconfigurationarn_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BackfillMatchmakingRequest::set_allocated_matchmakingconfigurationarn(std::string* matchmakingconfigurationarn) {
  if (matchmakingconfigurationarn != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  matchmakingconfigurationarn_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), matchmakingconfigurationarn,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.BackfillMatchmakingRequest.matchmakingConfigurationArn)
}

// repeated .com.amazon.whitewater.auxproxy.pbuffer.Player players = 4;
inline int BackfillMatchmakingRequest::_internal_players_size() const {
  return players_.size();
}
inline int BackfillMatchmakingRequest::players_size() const {
  return _internal_players_size();
}
inline void BackfillMatchmakingRequest::clear_players() {
  players_.Clear();
}
inline ::com::amazon::whitewater::auxproxy::pbuffer::Player* BackfillMatchmakingRequest::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.BackfillMatchmakingRequest.players)
  return players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::amazon::whitewater::auxproxy::pbuffer::Player >*
BackfillMatchmakingRequest::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:com.amazon.whitewater.auxproxy.pbuffer.BackfillMatchmakingRequest.players)
  return &players_;
}
inline const ::com::amazon::whitewater::auxproxy::pbuffer::Player& BackfillMatchmakingRequest::_internal_players(int index) const {
  return players_.Get(index);
}
inline const ::com::amazon::whitewater::auxproxy::pbuffer::Player& BackfillMatchmakingRequest::players(int index) const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.BackfillMatchmakingRequest.players)
  return _internal_players(index);
}
inline ::com::amazon::whitewater::auxproxy::pbuffer::Player* BackfillMatchmakingRequest::_internal_add_players() {
  return players_.Add();
}
inline ::com::amazon::whitewater::auxproxy::pbuffer::Player* BackfillMatchmakingRequest::add_players() {
  // @@protoc_insertion_point(field_add:com.amazon.whitewater.auxproxy.pbuffer.BackfillMatchmakingRequest.players)
  return _internal_add_players();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::amazon::whitewater::auxproxy::pbuffer::Player >&
BackfillMatchmakingRequest::players() const {
  // @@protoc_insertion_point(field_list:com.amazon.whitewater.auxproxy.pbuffer.BackfillMatchmakingRequest.players)
  return players_;
}

// -------------------------------------------------------------------

// StopMatchmakingRequest

// optional string ticketId = 1;
inline bool StopMatchmakingRequest::_internal_has_ticketid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StopMatchmakingRequest::has_ticketid() const {
  return _internal_has_ticketid();
}
inline void StopMatchmakingRequest::clear_ticketid() {
  ticketid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StopMatchmakingRequest::ticketid() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.StopMatchmakingRequest.ticketId)
  return _internal_ticketid();
}
inline void StopMatchmakingRequest::set_ticketid(const std::string& value) {
  _internal_set_ticketid(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.StopMatchmakingRequest.ticketId)
}
inline std::string* StopMatchmakingRequest::mutable_ticketid() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.StopMatchmakingRequest.ticketId)
  return _internal_mutable_ticketid();
}
inline const std::string& StopMatchmakingRequest::_internal_ticketid() const {
  return ticketid_.Get();
}
inline void StopMatchmakingRequest::_internal_set_ticketid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ticketid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void StopMatchmakingRequest::set_ticketid(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  ticketid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.StopMatchmakingRequest.ticketId)
}
inline void StopMatchmakingRequest::set_ticketid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  ticketid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.StopMatchmakingRequest.ticketId)
}
inline void StopMatchmakingRequest::set_ticketid(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  ticketid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.StopMatchmakingRequest.ticketId)
}
inline std::string* StopMatchmakingRequest::_internal_mutable_ticketid() {
  _has_bits_[0] |= 0x00000001u;
  return ticketid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* StopMatchmakingRequest::release_ticketid() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.StopMatchmakingRequest.ticketId)
  if (!_internal_has_ticketid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return ticketid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void StopMatchmakingRequest::set_allocated_ticketid(std::string* ticketid) {
  if (ticketid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ticketid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ticketid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.StopMatchmakingRequest.ticketId)
}

// optional string gameSessionArn = 2;
inline bool StopMatchmakingRequest::_internal_has_gamesessionarn() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StopMatchmakingRequest::has_gamesessionarn() const {
  return _internal_has_gamesessionarn();
}
inline void StopMatchmakingRequest::clear_gamesessionarn() {
  gamesessionarn_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StopMatchmakingRequest::gamesessionarn() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.StopMatchmakingRequest.gameSessionArn)
  return _internal_gamesessionarn();
}
inline void StopMatchmakingRequest::set_gamesessionarn(const std::string& value) {
  _internal_set_gamesessionarn(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.StopMatchmakingRequest.gameSessionArn)
}
inline std::string* StopMatchmakingRequest::mutable_gamesessionarn() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.StopMatchmakingRequest.gameSessionArn)
  return _internal_mutable_gamesessionarn();
}
inline const std::string& StopMatchmakingRequest::_internal_gamesessionarn() const {
  return gamesessionarn_.Get();
}
inline void StopMatchmakingRequest::_internal_set_gamesessionarn(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  gamesessionarn_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void StopMatchmakingRequest::set_gamesessionarn(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  gamesessionarn_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.StopMatchmakingRequest.gameSessionArn)
}
inline void StopMatchmakingRequest::set_gamesessionarn(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  gamesessionarn_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.StopMatchmakingRequest.gameSessionArn)
}
inline void StopMatchmakingRequest::set_gamesessionarn(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  gamesessionarn_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.StopMatchmakingRequest.gameSessionArn)
}
inline std::string* StopMatchmakingRequest::_internal_mutable_gamesessionarn() {
  _has_bits_[0] |= 0x00000002u;
  return gamesessionarn_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* StopMatchmakingRequest::release_gamesessionarn() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.StopMatchmakingRequest.gameSessionArn)
  if (!_internal_has_gamesessionarn()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return gamesessionarn_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void StopMatchmakingRequest::set_allocated_gamesessionarn(std::string* gamesessionarn) {
  if (gamesessionarn != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  gamesessionarn_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gamesessionarn,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.StopMatchmakingRequest.gameSessionArn)
}

// optional string matchmakingConfigurationArn = 3;
inline bool StopMatchmakingRequest::_internal_has_matchmakingconfigurationarn() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StopMatchmakingRequest::has_matchmakingconfigurationarn() const {
  return _internal_has_matchmakingconfigurationarn();
}
inline void StopMatchmakingRequest::clear_matchmakingconfigurationarn() {
  matchmakingconfigurationarn_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& StopMatchmakingRequest::matchmakingconfigurationarn() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.StopMatchmakingRequest.matchmakingConfigurationArn)
  return _internal_matchmakingconfigurationarn();
}
inline void StopMatchmakingRequest::set_matchmakingconfigurationarn(const std::string& value) {
  _internal_set_matchmakingconfigurationarn(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.StopMatchmakingRequest.matchmakingConfigurationArn)
}
inline std::string* StopMatchmakingRequest::mutable_matchmakingconfigurationarn() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.StopMatchmakingRequest.matchmakingConfigurationArn)
  return _internal_mutable_matchmakingconfigurationarn();
}
inline const std::string& StopMatchmakingRequest::_internal_matchmakingconfigurationarn() const {
  return matchmakingconfigurationarn_.Get();
}
inline void StopMatchmakingRequest::_internal_set_matchmakingconfigurationarn(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  matchmakingconfigurationarn_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void StopMatchmakingRequest::set_matchmakingconfigurationarn(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  matchmakingconfigurationarn_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.StopMatchmakingRequest.matchmakingConfigurationArn)
}
inline void StopMatchmakingRequest::set_matchmakingconfigurationarn(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  matchmakingconfigurationarn_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.StopMatchmakingRequest.matchmakingConfigurationArn)
}
inline void StopMatchmakingRequest::set_matchmakingconfigurationarn(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  matchmakingconfigurationarn_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.StopMatchmakingRequest.matchmakingConfigurationArn)
}
inline std::string* StopMatchmakingRequest::_internal_mutable_matchmakingconfigurationarn() {
  _has_bits_[0] |= 0x00000004u;
  return matchmakingconfigurationarn_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* StopMatchmakingRequest::release_matchmakingconfigurationarn() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.StopMatchmakingRequest.matchmakingConfigurationArn)
  if (!_internal_has_matchmakingconfigurationarn()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return matchmakingconfigurationarn_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void StopMatchmakingRequest::set_allocated_matchmakingconfigurationarn(std::string* matchmakingconfigurationarn) {
  if (matchmakingconfigurationarn != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  matchmakingconfigurationarn_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), matchmakingconfigurationarn,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.StopMatchmakingRequest.matchmakingConfigurationArn)
}

// -------------------------------------------------------------------

// GetInstanceCertificate

// -------------------------------------------------------------------

// BackfillMatchmakingResponse

// optional string ticketId = 1;
inline bool BackfillMatchmakingResponse::_internal_has_ticketid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BackfillMatchmakingResponse::has_ticketid() const {
  return _internal_has_ticketid();
}
inline void BackfillMatchmakingResponse::clear_ticketid() {
  ticketid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BackfillMatchmakingResponse::ticketid() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.BackfillMatchmakingResponse.ticketId)
  return _internal_ticketid();
}
inline void BackfillMatchmakingResponse::set_ticketid(const std::string& value) {
  _internal_set_ticketid(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.BackfillMatchmakingResponse.ticketId)
}
inline std::string* BackfillMatchmakingResponse::mutable_ticketid() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.BackfillMatchmakingResponse.ticketId)
  return _internal_mutable_ticketid();
}
inline const std::string& BackfillMatchmakingResponse::_internal_ticketid() const {
  return ticketid_.Get();
}
inline void BackfillMatchmakingResponse::_internal_set_ticketid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ticketid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void BackfillMatchmakingResponse::set_ticketid(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  ticketid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.BackfillMatchmakingResponse.ticketId)
}
inline void BackfillMatchmakingResponse::set_ticketid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  ticketid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.BackfillMatchmakingResponse.ticketId)
}
inline void BackfillMatchmakingResponse::set_ticketid(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  ticketid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.BackfillMatchmakingResponse.ticketId)
}
inline std::string* BackfillMatchmakingResponse::_internal_mutable_ticketid() {
  _has_bits_[0] |= 0x00000001u;
  return ticketid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* BackfillMatchmakingResponse::release_ticketid() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.BackfillMatchmakingResponse.ticketId)
  if (!_internal_has_ticketid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return ticketid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BackfillMatchmakingResponse::set_allocated_ticketid(std::string* ticketid) {
  if (ticketid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ticketid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ticketid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.BackfillMatchmakingResponse.ticketId)
}

// -------------------------------------------------------------------

// DescribePlayerSessionsResponse

// optional string nextToken = 1;
inline bool DescribePlayerSessionsResponse::_internal_has_nexttoken() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DescribePlayerSessionsResponse::has_nexttoken() const {
  return _internal_has_nexttoken();
}
inline void DescribePlayerSessionsResponse::clear_nexttoken() {
  nexttoken_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DescribePlayerSessionsResponse::nexttoken() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsResponse.nextToken)
  return _internal_nexttoken();
}
inline void DescribePlayerSessionsResponse::set_nexttoken(const std::string& value) {
  _internal_set_nexttoken(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsResponse.nextToken)
}
inline std::string* DescribePlayerSessionsResponse::mutable_nexttoken() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsResponse.nextToken)
  return _internal_mutable_nexttoken();
}
inline const std::string& DescribePlayerSessionsResponse::_internal_nexttoken() const {
  return nexttoken_.Get();
}
inline void DescribePlayerSessionsResponse::_internal_set_nexttoken(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  nexttoken_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void DescribePlayerSessionsResponse::set_nexttoken(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  nexttoken_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsResponse.nextToken)
}
inline void DescribePlayerSessionsResponse::set_nexttoken(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  nexttoken_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsResponse.nextToken)
}
inline void DescribePlayerSessionsResponse::set_nexttoken(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  nexttoken_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsResponse.nextToken)
}
inline std::string* DescribePlayerSessionsResponse::_internal_mutable_nexttoken() {
  _has_bits_[0] |= 0x00000001u;
  return nexttoken_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* DescribePlayerSessionsResponse::release_nexttoken() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsResponse.nextToken)
  if (!_internal_has_nexttoken()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return nexttoken_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DescribePlayerSessionsResponse::set_allocated_nexttoken(std::string* nexttoken) {
  if (nexttoken != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  nexttoken_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nexttoken,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsResponse.nextToken)
}

// repeated .com.amazon.whitewater.auxproxy.pbuffer.PlayerSession playerSessions = 2;
inline int DescribePlayerSessionsResponse::_internal_playersessions_size() const {
  return playersessions_.size();
}
inline int DescribePlayerSessionsResponse::playersessions_size() const {
  return _internal_playersessions_size();
}
inline void DescribePlayerSessionsResponse::clear_playersessions() {
  playersessions_.Clear();
}
inline ::com::amazon::whitewater::auxproxy::pbuffer::PlayerSession* DescribePlayerSessionsResponse::mutable_playersessions(int index) {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsResponse.playerSessions)
  return playersessions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::amazon::whitewater::auxproxy::pbuffer::PlayerSession >*
DescribePlayerSessionsResponse::mutable_playersessions() {
  // @@protoc_insertion_point(field_mutable_list:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsResponse.playerSessions)
  return &playersessions_;
}
inline const ::com::amazon::whitewater::auxproxy::pbuffer::PlayerSession& DescribePlayerSessionsResponse::_internal_playersessions(int index) const {
  return playersessions_.Get(index);
}
inline const ::com::amazon::whitewater::auxproxy::pbuffer::PlayerSession& DescribePlayerSessionsResponse::playersessions(int index) const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsResponse.playerSessions)
  return _internal_playersessions(index);
}
inline ::com::amazon::whitewater::auxproxy::pbuffer::PlayerSession* DescribePlayerSessionsResponse::_internal_add_playersessions() {
  return playersessions_.Add();
}
inline ::com::amazon::whitewater::auxproxy::pbuffer::PlayerSession* DescribePlayerSessionsResponse::add_playersessions() {
  // @@protoc_insertion_point(field_add:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsResponse.playerSessions)
  return _internal_add_playersessions();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::amazon::whitewater::auxproxy::pbuffer::PlayerSession >&
DescribePlayerSessionsResponse::playersessions() const {
  // @@protoc_insertion_point(field_list:com.amazon.whitewater.auxproxy.pbuffer.DescribePlayerSessionsResponse.playerSessions)
  return playersessions_;
}

// -------------------------------------------------------------------

// GetInstanceCertificateResponse

// optional string certificatePath = 1;
inline bool GetInstanceCertificateResponse::_internal_has_certificatepath() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetInstanceCertificateResponse::has_certificatepath() const {
  return _internal_has_certificatepath();
}
inline void GetInstanceCertificateResponse::clear_certificatepath() {
  certificatepath_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetInstanceCertificateResponse::certificatepath() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.GetInstanceCertificateResponse.certificatePath)
  return _internal_certificatepath();
}
inline void GetInstanceCertificateResponse::set_certificatepath(const std::string& value) {
  _internal_set_certificatepath(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.GetInstanceCertificateResponse.certificatePath)
}
inline std::string* GetInstanceCertificateResponse::mutable_certificatepath() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.GetInstanceCertificateResponse.certificatePath)
  return _internal_mutable_certificatepath();
}
inline const std::string& GetInstanceCertificateResponse::_internal_certificatepath() const {
  return certificatepath_.Get();
}
inline void GetInstanceCertificateResponse::_internal_set_certificatepath(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  certificatepath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void GetInstanceCertificateResponse::set_certificatepath(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  certificatepath_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.GetInstanceCertificateResponse.certificatePath)
}
inline void GetInstanceCertificateResponse::set_certificatepath(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  certificatepath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.GetInstanceCertificateResponse.certificatePath)
}
inline void GetInstanceCertificateResponse::set_certificatepath(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  certificatepath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.GetInstanceCertificateResponse.certificatePath)
}
inline std::string* GetInstanceCertificateResponse::_internal_mutable_certificatepath() {
  _has_bits_[0] |= 0x00000001u;
  return certificatepath_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* GetInstanceCertificateResponse::release_certificatepath() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.GetInstanceCertificateResponse.certificatePath)
  if (!_internal_has_certificatepath()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return certificatepath_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetInstanceCertificateResponse::set_allocated_certificatepath(std::string* certificatepath) {
  if (certificatepath != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  certificatepath_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), certificatepath,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.GetInstanceCertificateResponse.certificatePath)
}

// optional string certificateChainPath = 2;
inline bool GetInstanceCertificateResponse::_internal_has_certificatechainpath() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GetInstanceCertificateResponse::has_certificatechainpath() const {
  return _internal_has_certificatechainpath();
}
inline void GetInstanceCertificateResponse::clear_certificatechainpath() {
  certificatechainpath_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GetInstanceCertificateResponse::certificatechainpath() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.GetInstanceCertificateResponse.certificateChainPath)
  return _internal_certificatechainpath();
}
inline void GetInstanceCertificateResponse::set_certificatechainpath(const std::string& value) {
  _internal_set_certificatechainpath(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.GetInstanceCertificateResponse.certificateChainPath)
}
inline std::string* GetInstanceCertificateResponse::mutable_certificatechainpath() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.GetInstanceCertificateResponse.certificateChainPath)
  return _internal_mutable_certificatechainpath();
}
inline const std::string& GetInstanceCertificateResponse::_internal_certificatechainpath() const {
  return certificatechainpath_.Get();
}
inline void GetInstanceCertificateResponse::_internal_set_certificatechainpath(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  certificatechainpath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void GetInstanceCertificateResponse::set_certificatechainpath(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  certificatechainpath_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.GetInstanceCertificateResponse.certificateChainPath)
}
inline void GetInstanceCertificateResponse::set_certificatechainpath(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  certificatechainpath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.GetInstanceCertificateResponse.certificateChainPath)
}
inline void GetInstanceCertificateResponse::set_certificatechainpath(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  certificatechainpath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.GetInstanceCertificateResponse.certificateChainPath)
}
inline std::string* GetInstanceCertificateResponse::_internal_mutable_certificatechainpath() {
  _has_bits_[0] |= 0x00000002u;
  return certificatechainpath_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* GetInstanceCertificateResponse::release_certificatechainpath() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.GetInstanceCertificateResponse.certificateChainPath)
  if (!_internal_has_certificatechainpath()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return certificatechainpath_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetInstanceCertificateResponse::set_allocated_certificatechainpath(std::string* certificatechainpath) {
  if (certificatechainpath != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  certificatechainpath_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), certificatechainpath,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.GetInstanceCertificateResponse.certificateChainPath)
}

// optional string privateKeyPath = 3;
inline bool GetInstanceCertificateResponse::_internal_has_privatekeypath() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GetInstanceCertificateResponse::has_privatekeypath() const {
  return _internal_has_privatekeypath();
}
inline void GetInstanceCertificateResponse::clear_privatekeypath() {
  privatekeypath_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& GetInstanceCertificateResponse::privatekeypath() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.GetInstanceCertificateResponse.privateKeyPath)
  return _internal_privatekeypath();
}
inline void GetInstanceCertificateResponse::set_privatekeypath(const std::string& value) {
  _internal_set_privatekeypath(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.GetInstanceCertificateResponse.privateKeyPath)
}
inline std::string* GetInstanceCertificateResponse::mutable_privatekeypath() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.GetInstanceCertificateResponse.privateKeyPath)
  return _internal_mutable_privatekeypath();
}
inline const std::string& GetInstanceCertificateResponse::_internal_privatekeypath() const {
  return privatekeypath_.Get();
}
inline void GetInstanceCertificateResponse::_internal_set_privatekeypath(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  privatekeypath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void GetInstanceCertificateResponse::set_privatekeypath(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  privatekeypath_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.GetInstanceCertificateResponse.privateKeyPath)
}
inline void GetInstanceCertificateResponse::set_privatekeypath(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  privatekeypath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.GetInstanceCertificateResponse.privateKeyPath)
}
inline void GetInstanceCertificateResponse::set_privatekeypath(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  privatekeypath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.GetInstanceCertificateResponse.privateKeyPath)
}
inline std::string* GetInstanceCertificateResponse::_internal_mutable_privatekeypath() {
  _has_bits_[0] |= 0x00000004u;
  return privatekeypath_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* GetInstanceCertificateResponse::release_privatekeypath() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.GetInstanceCertificateResponse.privateKeyPath)
  if (!_internal_has_privatekeypath()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return privatekeypath_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetInstanceCertificateResponse::set_allocated_privatekeypath(std::string* privatekeypath) {
  if (privatekeypath != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  privatekeypath_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), privatekeypath,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.GetInstanceCertificateResponse.privateKeyPath)
}

// optional string hostName = 4;
inline bool GetInstanceCertificateResponse::_internal_has_hostname() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GetInstanceCertificateResponse::has_hostname() const {
  return _internal_has_hostname();
}
inline void GetInstanceCertificateResponse::clear_hostname() {
  hostname_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& GetInstanceCertificateResponse::hostname() const {
  // @@protoc_insertion_point(field_get:com.amazon.whitewater.auxproxy.pbuffer.GetInstanceCertificateResponse.hostName)
  return _internal_hostname();
}
inline void GetInstanceCertificateResponse::set_hostname(const std::string& value) {
  _internal_set_hostname(value);
  // @@protoc_insertion_point(field_set:com.amazon.whitewater.auxproxy.pbuffer.GetInstanceCertificateResponse.hostName)
}
inline std::string* GetInstanceCertificateResponse::mutable_hostname() {
  // @@protoc_insertion_point(field_mutable:com.amazon.whitewater.auxproxy.pbuffer.GetInstanceCertificateResponse.hostName)
  return _internal_mutable_hostname();
}
inline const std::string& GetInstanceCertificateResponse::_internal_hostname() const {
  return hostname_.Get();
}
inline void GetInstanceCertificateResponse::_internal_set_hostname(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  hostname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void GetInstanceCertificateResponse::set_hostname(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  hostname_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:com.amazon.whitewater.auxproxy.pbuffer.GetInstanceCertificateResponse.hostName)
}
inline void GetInstanceCertificateResponse::set_hostname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  hostname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:com.amazon.whitewater.auxproxy.pbuffer.GetInstanceCertificateResponse.hostName)
}
inline void GetInstanceCertificateResponse::set_hostname(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000008u;
  hostname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:com.amazon.whitewater.auxproxy.pbuffer.GetInstanceCertificateResponse.hostName)
}
inline std::string* GetInstanceCertificateResponse::_internal_mutable_hostname() {
  _has_bits_[0] |= 0x00000008u;
  return hostname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* GetInstanceCertificateResponse::release_hostname() {
  // @@protoc_insertion_point(field_release:com.amazon.whitewater.auxproxy.pbuffer.GetInstanceCertificateResponse.hostName)
  if (!_internal_has_hostname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return hostname_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetInstanceCertificateResponse::set_allocated_hostname(std::string* hostname) {
  if (hostname != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  hostname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hostname,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:com.amazon.whitewater.auxproxy.pbuffer.GetInstanceCertificateResponse.hostName)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pbuffer
}  // namespace auxproxy
}  // namespace whitewater
}  // namespace amazon
}  // namespace com

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::com::amazon::whitewater::auxproxy::pbuffer::GameLiftResponseStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::amazon::whitewater::auxproxy::pbuffer::GameLiftResponseStatus>() {
  return ::com::amazon::whitewater::auxproxy::pbuffer::GameLiftResponseStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_sdk_2eproto
